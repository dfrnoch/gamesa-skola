{"resolvedId":"C:/Users/tobis/gamesa-skola/node_modules/solid-trpc/dist/shared/hooks/createHooksInternal.jsx?v=2f17421b","transforms":[{"name":"__load__","result":"import { createInfiniteQuery as __useInfiniteQuery, createMutation as __useMutation, createQuery as __useQuery, hashQueryKey, QueryClientProvider, } from \"@tanstack/solid-query\";\nimport { createTRPCClient, } from \"@trpc/client\";\nimport { createEffect, createMemo, createSignal, onCleanup, onMount, useContext as __useContext, } from \"solid-js\";\nimport { TRPCContext, } from \"../../internals/context\";\nimport { getArrayQueryKey } from \"../../internals/getArrayQueryKey\";\nfunction getClientArgs(pathAndInput, opts) {\n    const [path, input] = pathAndInput;\n    return [path, input, opts?.trpc];\n}\n/**\n * Create strongly typed react hooks\n * @internal\n */\nexport function createHooksInternal(config) {\n    // const mutationSuccessOverride: UseMutationOverride[\"onSuccess\"] =\n    //   config?.unstable_overrides?.useMutation?.onSuccess ??\n    //   ((options) => options.originalFn());\n    const Context = (config?.context ?? TRPCContext);\n    // const SolidQueryContext = config?.solidQueryContext as Context<\n    //   QueryClient | undefined\n    // >;\n    const createClient = (opts) => {\n        return createTRPCClient(opts);\n    };\n    const TRPCProvider = (props) => {\n        const { abortOnUnmount = false, client, queryClient, ssrContext } = props;\n        const [ssrState, setSSRState] = createSignal(props.ssrState ?? false);\n        onMount(() => {\n            // Only updating state to `mounted` if we are using SSR.\n            // This makes it so we don't have an unnecessary re-render when opting out of SSR.\n            setSSRState((state) => (state ? \"mounted\" : false));\n        });\n        return (<Context.Provider value={{\n                abortOnUnmount,\n                queryClient,\n                client,\n                ssrContext: ssrContext || null,\n                ssrState,\n                fetchQuery: (pathAndInput, opts) => {\n                    return queryClient.fetchQuery(getArrayQueryKey(pathAndInput), () => client.query(...getClientArgs(pathAndInput, opts)), opts);\n                },\n                fetchInfiniteQuery: (pathAndInput, opts) => {\n                    return queryClient.fetchInfiniteQuery(getArrayQueryKey(pathAndInput), ({ pageParam }) => {\n                        const [path, input] = pathAndInput;\n                        const actualInput = { ...input, cursor: pageParam };\n                        return client.query(...getClientArgs([path, actualInput], opts));\n                    }, opts);\n                },\n                prefetchQuery: (pathAndInput, opts) => {\n                    return queryClient.prefetchQuery(getArrayQueryKey(pathAndInput), () => client.query(...getClientArgs(pathAndInput, opts)), opts);\n                },\n                prefetchInfiniteQuery: (pathAndInput, opts) => {\n                    return queryClient.prefetchInfiniteQuery(getArrayQueryKey(pathAndInput), ({ pageParam }) => {\n                        const [path, input] = pathAndInput;\n                        const actualInput = { ...input, cursor: pageParam };\n                        return client.query(...getClientArgs([path, actualInput], opts));\n                    }, opts);\n                },\n                invalidateQueries: (...args) => {\n                    const [queryKey, ...rest] = args;\n                    return queryClient.invalidateQueries(getArrayQueryKey(queryKey), ...rest);\n                },\n                refetchQueries: (...args) => {\n                    const [queryKey, ...rest] = args;\n                    return queryClient.refetchQueries(getArrayQueryKey(queryKey), ...rest);\n                },\n                cancelQuery: (pathAndInput) => {\n                    return queryClient.cancelQueries(getArrayQueryKey(pathAndInput));\n                },\n                setQueryData: (...args) => {\n                    const [queryKey, ...rest] = args;\n                    return queryClient.setQueryData(getArrayQueryKey(queryKey), ...rest);\n                },\n                getQueryData: (...args) => {\n                    const [queryKey, ...rest] = args;\n                    return queryClient.getQueryData(getArrayQueryKey(queryKey), ...rest);\n                },\n                setInfiniteQueryData: (...args) => {\n                    const [queryKey, ...rest] = args;\n                    return queryClient.setQueryData(getArrayQueryKey(queryKey), ...rest);\n                },\n                getInfiniteQueryData: (...args) => {\n                    const [queryKey, ...rest] = args;\n                    return queryClient.getQueryData(getArrayQueryKey(queryKey), ...rest);\n                },\n            }}>\r\n        <QueryClientProvider client={queryClient} {...(props.queryClientOpts ?? {})}>\r\n          {props.children}\r\n        </QueryClientProvider>\r\n      </Context.Provider>);\n    };\n    function useContext() {\n        return __useContext(Context);\n    }\n    /**\n     * Hack to make sure errors return `status`='error` when doing SSR\n     * @link https://github.com/trpc/trpc/pull/1645\n     */\n    function useSSRQueryOptionsIfNeeded(pathAndInput, opts) {\n        const { queryClient, ssrState } = useContext();\n        return ssrState() &&\n            ssrState() !== \"mounted\" &&\n            queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput))?.state\n                .status === \"error\"\n            ? {\n                retryOnMount: false,\n                ...opts,\n            }\n            : opts;\n    }\n    function useQuery(pathAndInput, opts) {\n        const ctx = useContext();\n        // createEffect(() => console.log(\"opts\", opts?.()));\n        if (typeof window === \"undefined\" &&\n            ctx.ssrState() === \"prepass\" &&\n            opts?.trpc?.ssr !== false &&\n            opts?.enabled !== false &&\n            !ctx.queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput()))) {\n            void ctx.prefetchQuery(pathAndInput(), opts);\n        }\n        const shouldAbortOnUnmount = () => opts?.trpc?.abortOnUnmount ?? ctx?.abortOnUnmount ?? false;\n        return __useQuery(() => getArrayQueryKey(pathAndInput()), (queryFunctionContext) => {\n            const actualOpts = () => ({\n                ...opts,\n                trpc: {\n                    ...opts?.trpc,\n                    ...(shouldAbortOnUnmount()\n                        ? { signal: queryFunctionContext.signal }\n                        : {}),\n                },\n            });\n            return ctx.client.query(...getClientArgs(pathAndInput(), actualOpts()));\n        }, opts);\n    }\n    function useMutation(path, opts) {\n        const ctx = useContext();\n        // const queryClient = useQueryClient({ context: SolidQueryContext });\n        return __useMutation((input) => {\n            const actualPath = Array.isArray(path) ? path[0] : path;\n            return ctx.client.mutation(...getClientArgs([actualPath, input], opts));\n        }, opts);\n    }\n    /* istanbul ignore next */\n    /**\n     * ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️\n     *  **Experimental.** API might change without major version bump\n     * ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠\n     */\n    function useSubscription(pathAndInput, opts) {\n        const ctx = useContext();\n        return createEffect(() => {\n            if (!(opts.enabled ?? true)) {\n                return;\n            }\n            // noop\n            (() => {\n                return hashQueryKey(pathAndInput());\n            })();\n            let isStopped = false;\n            const subscription = ctx.client.subscription(pathAndInput()[0], (pathAndInput()[1] ?? undefined), {\n                onStarted: () => {\n                    if (!isStopped) {\n                        opts?.onStarted?.();\n                    }\n                },\n                onData: (data) => {\n                    if (!isStopped) {\n                        opts?.onData(data);\n                    }\n                },\n                onError: (err) => {\n                    if (!isStopped) {\n                        opts?.onError?.(err);\n                    }\n                },\n            });\n            onCleanup(() => {\n                isStopped = true;\n                subscription.unsubscribe();\n            });\n        });\n    }\n    function useInfiniteQuery(pathAndInput, opts) {\n        const ctx = useContext();\n        if (typeof window === \"undefined\" &&\n            ctx.ssrState() === \"prepass\" &&\n            opts?.trpc?.ssr !== false &&\n            opts?.enabled !== false &&\n            !ctx.queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput()))) {\n            void ctx.prefetchInfiniteQuery(pathAndInput, opts);\n        }\n        const ssrOpts = useSSRQueryOptionsIfNeeded(pathAndInput(), opts);\n        // request option should take priority over global\n        const shouldAbortOnUnmount = opts?.trpc?.abortOnUnmount ?? ctx?.abortOnUnmount ?? false;\n        return __useInfiniteQuery(() => getArrayQueryKey(pathAndInput()), (queryFunctionContext) => {\n            const actualOpts = () => ({\n                ...ssrOpts,\n                trpc: {\n                    ...ssrOpts?.trpc,\n                    ...(shouldAbortOnUnmount\n                        ? { signal: queryFunctionContext.signal }\n                        : {}),\n                },\n            });\n            const actualInput = {\n                ...(pathAndInput()[1] ?? {}),\n                cursor: queryFunctionContext.pageParam,\n            };\n            return ctx.client.query(...getClientArgs([pathAndInput()[0], actualInput], actualOpts()));\n        }, ssrOpts);\n    }\n    const useDehydratedState = (client, trpcState) => {\n        const transformed = createMemo(() => {\n            if (!trpcState) {\n                return trpcState;\n            }\n            return client.runtime.transformer.deserialize(trpcState);\n        });\n        return transformed;\n    };\n    return {\n        Provider: TRPCProvider,\n        createClient,\n        useContext,\n        useQuery,\n        useMutation,\n        useSubscription,\n        useDehydratedState,\n        useInfiniteQuery,\n    };\n}\n/**\n * Hack to infer the type of `createReactQueryHooks`\n * @link https://stackoverflow.com/a/59072991\n */\nclass GnClass {\n    fn() {\n        return createHooksInternal();\n    }\n}\n","start":1676889524272,"end":1676889524272},{"name":"solid","result":"import { createComponent as _$createComponent } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { createInfiniteQuery as __useInfiniteQuery, createMutation as __useMutation, createQuery as __useQuery, hashQueryKey, QueryClientProvider } from \"@tanstack/solid-query\";\nimport { createTRPCClient } from \"@trpc/client\";\nimport { createEffect, createMemo, createSignal, onCleanup, onMount, useContext as __useContext } from \"solid-js\";\nimport { TRPCContext } from \"../../internals/context\";\nimport { getArrayQueryKey } from \"../../internals/getArrayQueryKey\";\nfunction getClientArgs(pathAndInput, opts) {\n  const [path, input] = pathAndInput;\n  return [path, input, opts?.trpc];\n}\n/**\n * Create strongly typed react hooks\n * @internal\n */\nexport function createHooksInternal(config) {\n  // const mutationSuccessOverride: UseMutationOverride[\"onSuccess\"] =\n  //   config?.unstable_overrides?.useMutation?.onSuccess ??\n  //   ((options) => options.originalFn());\n  const Context = config?.context ?? TRPCContext;\n  // const SolidQueryContext = config?.solidQueryContext as Context<\n  //   QueryClient | undefined\n  // >;\n  const createClient = opts => {\n    return createTRPCClient(opts);\n  };\n  const TRPCProvider = props => {\n    const {\n      abortOnUnmount = false,\n      client,\n      queryClient,\n      ssrContext\n    } = props;\n    const [ssrState, setSSRState] = createSignal(props.ssrState ?? false);\n    onMount(() => {\n      // Only updating state to `mounted` if we are using SSR.\n      // This makes it so we don't have an unnecessary re-render when opting out of SSR.\n      setSSRState(state => state ? \"mounted\" : false);\n    });\n    return _$createComponent(Context.Provider, {\n      value: {\n        abortOnUnmount,\n        queryClient,\n        client,\n        ssrContext: ssrContext || null,\n        ssrState,\n        fetchQuery: (pathAndInput, opts) => {\n          return queryClient.fetchQuery(getArrayQueryKey(pathAndInput), () => client.query(...getClientArgs(pathAndInput, opts)), opts);\n        },\n        fetchInfiniteQuery: (pathAndInput, opts) => {\n          return queryClient.fetchInfiniteQuery(getArrayQueryKey(pathAndInput), ({\n            pageParam\n          }) => {\n            const [path, input] = pathAndInput;\n            const actualInput = {\n              ...input,\n              cursor: pageParam\n            };\n            return client.query(...getClientArgs([path, actualInput], opts));\n          }, opts);\n        },\n        prefetchQuery: (pathAndInput, opts) => {\n          return queryClient.prefetchQuery(getArrayQueryKey(pathAndInput), () => client.query(...getClientArgs(pathAndInput, opts)), opts);\n        },\n        prefetchInfiniteQuery: (pathAndInput, opts) => {\n          return queryClient.prefetchInfiniteQuery(getArrayQueryKey(pathAndInput), ({\n            pageParam\n          }) => {\n            const [path, input] = pathAndInput;\n            const actualInput = {\n              ...input,\n              cursor: pageParam\n            };\n            return client.query(...getClientArgs([path, actualInput], opts));\n          }, opts);\n        },\n        invalidateQueries: (...args) => {\n          const [queryKey, ...rest] = args;\n          return queryClient.invalidateQueries(getArrayQueryKey(queryKey), ...rest);\n        },\n        refetchQueries: (...args) => {\n          const [queryKey, ...rest] = args;\n          return queryClient.refetchQueries(getArrayQueryKey(queryKey), ...rest);\n        },\n        cancelQuery: pathAndInput => {\n          return queryClient.cancelQueries(getArrayQueryKey(pathAndInput));\n        },\n        setQueryData: (...args) => {\n          const [queryKey, ...rest] = args;\n          return queryClient.setQueryData(getArrayQueryKey(queryKey), ...rest);\n        },\n        getQueryData: (...args) => {\n          const [queryKey, ...rest] = args;\n          return queryClient.getQueryData(getArrayQueryKey(queryKey), ...rest);\n        },\n        setInfiniteQueryData: (...args) => {\n          const [queryKey, ...rest] = args;\n          return queryClient.setQueryData(getArrayQueryKey(queryKey), ...rest);\n        },\n        getInfiniteQueryData: (...args) => {\n          const [queryKey, ...rest] = args;\n          return queryClient.getQueryData(getArrayQueryKey(queryKey), ...rest);\n        }\n      },\n      get children() {\n        return _$createComponent(QueryClientProvider, _$mergeProps({\n          client: queryClient\n        }, () => props.queryClientOpts ?? {}, {\n          get children() {\n            return props.children;\n          }\n        }));\n      }\n    });\n  };\n  function useContext() {\n    return __useContext(Context);\n  }\n  /**\n   * Hack to make sure errors return `status`='error` when doing SSR\n   * @link https://github.com/trpc/trpc/pull/1645\n   */\n  function useSSRQueryOptionsIfNeeded(pathAndInput, opts) {\n    const {\n      queryClient,\n      ssrState\n    } = useContext();\n    return ssrState() && ssrState() !== \"mounted\" && queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput))?.state.status === \"error\" ? {\n      retryOnMount: false,\n      ...opts\n    } : opts;\n  }\n  function useQuery(pathAndInput, opts) {\n    const ctx = useContext();\n    // createEffect(() => console.log(\"opts\", opts?.()));\n    if (typeof window === \"undefined\" && ctx.ssrState() === \"prepass\" && opts?.trpc?.ssr !== false && opts?.enabled !== false && !ctx.queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput()))) {\n      void ctx.prefetchQuery(pathAndInput(), opts);\n    }\n    const shouldAbortOnUnmount = () => opts?.trpc?.abortOnUnmount ?? ctx?.abortOnUnmount ?? false;\n    return __useQuery(() => getArrayQueryKey(pathAndInput()), queryFunctionContext => {\n      const actualOpts = () => ({\n        ...opts,\n        trpc: {\n          ...opts?.trpc,\n          ...(shouldAbortOnUnmount() ? {\n            signal: queryFunctionContext.signal\n          } : {})\n        }\n      });\n      return ctx.client.query(...getClientArgs(pathAndInput(), actualOpts()));\n    }, opts);\n  }\n  function useMutation(path, opts) {\n    const ctx = useContext();\n    // const queryClient = useQueryClient({ context: SolidQueryContext });\n    return __useMutation(input => {\n      const actualPath = Array.isArray(path) ? path[0] : path;\n      return ctx.client.mutation(...getClientArgs([actualPath, input], opts));\n    }, opts);\n  }\n  /* istanbul ignore next */\n  /**\n   * ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️\n   *  **Experimental.** API might change without major version bump\n   * ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠\n   */\n  function useSubscription(pathAndInput, opts) {\n    const ctx = useContext();\n    return createEffect(() => {\n      if (!(opts.enabled ?? true)) {\n        return;\n      }\n      // noop\n      (() => {\n        return hashQueryKey(pathAndInput());\n      })();\n      let isStopped = false;\n      const subscription = ctx.client.subscription(pathAndInput()[0], pathAndInput()[1] ?? undefined, {\n        onStarted: () => {\n          if (!isStopped) {\n            opts?.onStarted?.();\n          }\n        },\n        onData: data => {\n          if (!isStopped) {\n            opts?.onData(data);\n          }\n        },\n        onError: err => {\n          if (!isStopped) {\n            opts?.onError?.(err);\n          }\n        }\n      });\n      onCleanup(() => {\n        isStopped = true;\n        subscription.unsubscribe();\n      });\n    });\n  }\n  function useInfiniteQuery(pathAndInput, opts) {\n    const ctx = useContext();\n    if (typeof window === \"undefined\" && ctx.ssrState() === \"prepass\" && opts?.trpc?.ssr !== false && opts?.enabled !== false && !ctx.queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput()))) {\n      void ctx.prefetchInfiniteQuery(pathAndInput, opts);\n    }\n    const ssrOpts = useSSRQueryOptionsIfNeeded(pathAndInput(), opts);\n    // request option should take priority over global\n    const shouldAbortOnUnmount = opts?.trpc?.abortOnUnmount ?? ctx?.abortOnUnmount ?? false;\n    return __useInfiniteQuery(() => getArrayQueryKey(pathAndInput()), queryFunctionContext => {\n      const actualOpts = () => ({\n        ...ssrOpts,\n        trpc: {\n          ...ssrOpts?.trpc,\n          ...(shouldAbortOnUnmount ? {\n            signal: queryFunctionContext.signal\n          } : {})\n        }\n      });\n      const actualInput = {\n        ...(pathAndInput()[1] ?? {}),\n        cursor: queryFunctionContext.pageParam\n      };\n      return ctx.client.query(...getClientArgs([pathAndInput()[0], actualInput], actualOpts()));\n    }, ssrOpts);\n  }\n  const useDehydratedState = (client, trpcState) => {\n    const transformed = createMemo(() => {\n      if (!trpcState) {\n        return trpcState;\n      }\n      return client.runtime.transformer.deserialize(trpcState);\n    });\n    return transformed;\n  };\n  return {\n    Provider: TRPCProvider,\n    createClient,\n    useContext,\n    useQuery,\n    useMutation,\n    useSubscription,\n    useDehydratedState,\n    useInfiniteQuery\n  };\n}\n/**\n * Hack to infer the type of `createReactQueryHooks`\n * @link https://stackoverflow.com/a/59072991\n */\nclass GnClass {\n  fn() {\n    return createHooksInternal();\n  }\n}","start":1676889524272,"end":1676889524290,"order":"pre"},{"name":"vite:import-analysis","result":"import { createComponent as _$createComponent } from \"/node_modules/.vite/deps/solid-js_web.js?v=53da11be\";\nimport { mergeProps as _$mergeProps } from \"/node_modules/.vite/deps/solid-js_web.js?v=53da11be\";\nimport { createInfiniteQuery as __useInfiniteQuery, createMutation as __useMutation, createQuery as __useQuery, hashQueryKey, QueryClientProvider } from \"/node_modules/@tanstack/solid-query/build/solid/index.js?v=2f17421b\";\nimport { createTRPCClient } from \"/node_modules/.vite/deps/@trpc_client.js?v=2ac3ed7c\";\nimport { createEffect, createMemo, createSignal, onCleanup, onMount, useContext as __useContext } from \"/node_modules/.vite/deps/solid-js.js?v=53da11be\";\nimport { TRPCContext } from \"/node_modules/solid-trpc/dist/internals/context.jsx?v=2f17421b\";\nimport { getArrayQueryKey } from \"/node_modules/solid-trpc/dist/internals/getArrayQueryKey.js?v=2f17421b\";\nfunction getClientArgs(pathAndInput, opts) {\n  const [path, input] = pathAndInput;\n  return [path, input, opts?.trpc];\n}\n/**\n * Create strongly typed react hooks\n * @internal\n */\nexport function createHooksInternal(config) {\n  // const mutationSuccessOverride: UseMutationOverride[\"onSuccess\"] =\n  //   config?.unstable_overrides?.useMutation?.onSuccess ??\n  //   ((options) => options.originalFn());\n  const Context = config?.context ?? TRPCContext;\n  // const SolidQueryContext = config?.solidQueryContext as Context<\n  //   QueryClient | undefined\n  // >;\n  const createClient = opts => {\n    return createTRPCClient(opts);\n  };\n  const TRPCProvider = props => {\n    const {\n      abortOnUnmount = false,\n      client,\n      queryClient,\n      ssrContext\n    } = props;\n    const [ssrState, setSSRState] = createSignal(props.ssrState ?? false);\n    onMount(() => {\n      // Only updating state to `mounted` if we are using SSR.\n      // This makes it so we don't have an unnecessary re-render when opting out of SSR.\n      setSSRState(state => state ? \"mounted\" : false);\n    });\n    return _$createComponent(Context.Provider, {\n      value: {\n        abortOnUnmount,\n        queryClient,\n        client,\n        ssrContext: ssrContext || null,\n        ssrState,\n        fetchQuery: (pathAndInput, opts) => {\n          return queryClient.fetchQuery(getArrayQueryKey(pathAndInput), () => client.query(...getClientArgs(pathAndInput, opts)), opts);\n        },\n        fetchInfiniteQuery: (pathAndInput, opts) => {\n          return queryClient.fetchInfiniteQuery(getArrayQueryKey(pathAndInput), ({\n            pageParam\n          }) => {\n            const [path, input] = pathAndInput;\n            const actualInput = {\n              ...input,\n              cursor: pageParam\n            };\n            return client.query(...getClientArgs([path, actualInput], opts));\n          }, opts);\n        },\n        prefetchQuery: (pathAndInput, opts) => {\n          return queryClient.prefetchQuery(getArrayQueryKey(pathAndInput), () => client.query(...getClientArgs(pathAndInput, opts)), opts);\n        },\n        prefetchInfiniteQuery: (pathAndInput, opts) => {\n          return queryClient.prefetchInfiniteQuery(getArrayQueryKey(pathAndInput), ({\n            pageParam\n          }) => {\n            const [path, input] = pathAndInput;\n            const actualInput = {\n              ...input,\n              cursor: pageParam\n            };\n            return client.query(...getClientArgs([path, actualInput], opts));\n          }, opts);\n        },\n        invalidateQueries: (...args) => {\n          const [queryKey, ...rest] = args;\n          return queryClient.invalidateQueries(getArrayQueryKey(queryKey), ...rest);\n        },\n        refetchQueries: (...args) => {\n          const [queryKey, ...rest] = args;\n          return queryClient.refetchQueries(getArrayQueryKey(queryKey), ...rest);\n        },\n        cancelQuery: pathAndInput => {\n          return queryClient.cancelQueries(getArrayQueryKey(pathAndInput));\n        },\n        setQueryData: (...args) => {\n          const [queryKey, ...rest] = args;\n          return queryClient.setQueryData(getArrayQueryKey(queryKey), ...rest);\n        },\n        getQueryData: (...args) => {\n          const [queryKey, ...rest] = args;\n          return queryClient.getQueryData(getArrayQueryKey(queryKey), ...rest);\n        },\n        setInfiniteQueryData: (...args) => {\n          const [queryKey, ...rest] = args;\n          return queryClient.setQueryData(getArrayQueryKey(queryKey), ...rest);\n        },\n        getInfiniteQueryData: (...args) => {\n          const [queryKey, ...rest] = args;\n          return queryClient.getQueryData(getArrayQueryKey(queryKey), ...rest);\n        }\n      },\n      get children() {\n        return _$createComponent(QueryClientProvider, _$mergeProps({\n          client: queryClient\n        }, () => props.queryClientOpts ?? {}, {\n          get children() {\n            return props.children;\n          }\n        }));\n      }\n    });\n  };\n  function useContext() {\n    return __useContext(Context);\n  }\n  /**\n   * Hack to make sure errors return `status`='error` when doing SSR\n   * @link https://github.com/trpc/trpc/pull/1645\n   */\n  function useSSRQueryOptionsIfNeeded(pathAndInput, opts) {\n    const {\n      queryClient,\n      ssrState\n    } = useContext();\n    return ssrState() && ssrState() !== \"mounted\" && queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput))?.state.status === \"error\" ? {\n      retryOnMount: false,\n      ...opts\n    } : opts;\n  }\n  function useQuery(pathAndInput, opts) {\n    const ctx = useContext();\n    // createEffect(() => console.log(\"opts\", opts?.()));\n    if (typeof window === \"undefined\" && ctx.ssrState() === \"prepass\" && opts?.trpc?.ssr !== false && opts?.enabled !== false && !ctx.queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput()))) {\n      void ctx.prefetchQuery(pathAndInput(), opts);\n    }\n    const shouldAbortOnUnmount = () => opts?.trpc?.abortOnUnmount ?? ctx?.abortOnUnmount ?? false;\n    return __useQuery(() => getArrayQueryKey(pathAndInput()), queryFunctionContext => {\n      const actualOpts = () => ({\n        ...opts,\n        trpc: {\n          ...opts?.trpc,\n          ...(shouldAbortOnUnmount() ? {\n            signal: queryFunctionContext.signal\n          } : {})\n        }\n      });\n      return ctx.client.query(...getClientArgs(pathAndInput(), actualOpts()));\n    }, opts);\n  }\n  function useMutation(path, opts) {\n    const ctx = useContext();\n    // const queryClient = useQueryClient({ context: SolidQueryContext });\n    return __useMutation(input => {\n      const actualPath = Array.isArray(path) ? path[0] : path;\n      return ctx.client.mutation(...getClientArgs([actualPath, input], opts));\n    }, opts);\n  }\n  /* istanbul ignore next */\n  /**\n   * ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️\n   *  **Experimental.** API might change without major version bump\n   * ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠\n   */\n  function useSubscription(pathAndInput, opts) {\n    const ctx = useContext();\n    return createEffect(() => {\n      if (!(opts.enabled ?? true)) {\n        return;\n      }\n      // noop\n      (() => {\n        return hashQueryKey(pathAndInput());\n      })();\n      let isStopped = false;\n      const subscription = ctx.client.subscription(pathAndInput()[0], pathAndInput()[1] ?? undefined, {\n        onStarted: () => {\n          if (!isStopped) {\n            opts?.onStarted?.();\n          }\n        },\n        onData: data => {\n          if (!isStopped) {\n            opts?.onData(data);\n          }\n        },\n        onError: err => {\n          if (!isStopped) {\n            opts?.onError?.(err);\n          }\n        }\n      });\n      onCleanup(() => {\n        isStopped = true;\n        subscription.unsubscribe();\n      });\n    });\n  }\n  function useInfiniteQuery(pathAndInput, opts) {\n    const ctx = useContext();\n    if (typeof window === \"undefined\" && ctx.ssrState() === \"prepass\" && opts?.trpc?.ssr !== false && opts?.enabled !== false && !ctx.queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput()))) {\n      void ctx.prefetchInfiniteQuery(pathAndInput, opts);\n    }\n    const ssrOpts = useSSRQueryOptionsIfNeeded(pathAndInput(), opts);\n    // request option should take priority over global\n    const shouldAbortOnUnmount = opts?.trpc?.abortOnUnmount ?? ctx?.abortOnUnmount ?? false;\n    return __useInfiniteQuery(() => getArrayQueryKey(pathAndInput()), queryFunctionContext => {\n      const actualOpts = () => ({\n        ...ssrOpts,\n        trpc: {\n          ...ssrOpts?.trpc,\n          ...(shouldAbortOnUnmount ? {\n            signal: queryFunctionContext.signal\n          } : {})\n        }\n      });\n      const actualInput = {\n        ...(pathAndInput()[1] ?? {}),\n        cursor: queryFunctionContext.pageParam\n      };\n      return ctx.client.query(...getClientArgs([pathAndInput()[0], actualInput], actualOpts()));\n    }, ssrOpts);\n  }\n  const useDehydratedState = (client, trpcState) => {\n    const transformed = createMemo(() => {\n      if (!trpcState) {\n        return trpcState;\n      }\n      return client.runtime.transformer.deserialize(trpcState);\n    });\n    return transformed;\n  };\n  return {\n    Provider: TRPCProvider,\n    createClient,\n    useContext,\n    useQuery,\n    useMutation,\n    useSubscription,\n    useDehydratedState,\n    useInfiniteQuery\n  };\n}\n/**\n * Hack to infer the type of `createReactQueryHooks`\n * @link https://stackoverflow.com/a/59072991\n */\nclass GnClass {\n  fn() {\n    return createHooksInternal();\n  }\n}","start":1676889524290,"end":1676889524299,"order":"normal"}]}
