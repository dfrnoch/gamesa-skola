{"resolvedId":"/@solid-refresh","transforms":[{"name":"solid","result":"import { $DEVCOMP, createMemo, untrack, createSignal, DEV } from 'solid-js';\n\nfunction createProxy(source) {\n    return new Proxy(function hmrCompWrapper(props, ...rest) {\n        const s = source();\n        if (!s || $DEVCOMP in s) {\n            return createMemo(() => {\n                const c = source();\n                if (c) {\n                    return untrack(() => c(props));\n                }\n                return undefined;\n            });\n        }\n        // no $DEVCOMP means it did not go through devComponent so source() is a regular function, not a component\n        return s.call(this, props, ...rest);\n    }, {\n        get(_, property) {\n            return source()[property];\n        },\n        set(_, property, value) {\n            source()[property] = value;\n            return true;\n        }\n    });\n}\n\nfunction isListUpdated(a, b) {\n    if (a == null && b != null) {\n        return true;\n    }\n    if (a != null && b == null) {\n        return true;\n    }\n    if (a && b) {\n        if (a.length !== b.length) {\n            return true;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (!Object.is(a[i], b[i])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nfunction hot$1({ component: Comp, id, signature, dependencies }, hot) {\n    if (hot) {\n        const [comp, setComp] = createSignal(Comp, { internal: true });\n        const prev = hot.data;\n        // Check if there's previous data\n        if (prev && prev[id]) {\n            // Check if there's a new signature and dependency\n            // This is always new in standard HMR\n            if (signature && dependencies) {\n                // Check if signature changed\n                // or dependencies changed\n                if (prev[id].signature !== signature ||\n                    isListUpdated(prev[id].dependencies, dependencies)) {\n                    // Remount\n                    prev[id].dependencies = dependencies;\n                    prev[id].signature = signature;\n                    prev[id].setComp(() => Comp);\n                }\n            }\n            else {\n                prev[id].setComp(() => Comp);\n            }\n        }\n        hot.dispose(data => {\n            data[id] = prev\n                ? prev[id]\n                : {\n                    setComp,\n                    signature,\n                    dependencies\n                };\n        });\n        hot.accept();\n        return createProxy(comp);\n    }\n    return Comp;\n}\n\nconst HOT_DATA_PREFIX = \"solid-refresh-ctx\";\nfunction hot({ component: Comp, id, signature, dependencies }, hot) {\n    let Component = Comp;\n    function handler(newModule) {\n        const registration = newModule.$$registrations[id];\n        if (!registration) {\n            // For some reason, the registration was lost, invalidate\n            return true;\n        }\n        registration.component.setComp = Comp.setComp;\n        registration.component.signature = Comp.signature;\n        registration.component.dependencies = Comp.dependencies;\n        // Check if incoming module has signature\n        if (registration.signature && registration.dependencies) {\n            // Compare old signature and dependencies\n            if (registration.signature !== Comp.signature ||\n                isListUpdated(registration.dependencies, Comp.dependencies)) {\n                // Remount\n                Comp.dependencies = registration.dependencies;\n                Comp.signature = registration.signature;\n                Comp.setComp(() => registration.component);\n            }\n        }\n        else {\n            // No granular update, remount\n            Comp.setComp(() => registration.component);\n        }\n        registration.component.signature = Comp.signature;\n        registration.component.dependencies = Comp.dependencies;\n        return false;\n    }\n    if (hot && hot.data) {\n        const refreshData = (hot.data[HOT_DATA_PREFIX] = hot.data[HOT_DATA_PREFIX] || {});\n        if (refreshData[id]) {\n            Comp.setComp = refreshData[id].Comp.setComp;\n            return { Component: refreshData[id].Component, handler };\n        }\n        const [comp, setComp] = createSignal(Comp, { internal: true });\n        Comp.setComp = setComp;\n        Comp.dependencies = dependencies;\n        Comp.signature = signature;\n        Component = createProxy(comp);\n        refreshData[id] = { Component, Comp };\n    }\n    return { Component, handler };\n}\n\nlet warned = false;\nfunction shouldWarnAndDecline() {\n    const result = DEV && Object.keys(DEV).length;\n    if (result) {\n        return false;\n    }\n    if (!warned) {\n        console.warn(\"To use solid-refresh, you need to use the dev build of SolidJS. Make sure your build system supports package.json conditional exports and has the 'development' condition turned on.\");\n        warned = true;\n    }\n    return true;\n}\n\nexport { hot as esm, shouldWarnAndDecline, hot$1 as standard };\n","start":1676889523266,"end":1676889523266},{"name":"vite:import-analysis","result":"import { $DEVCOMP, createMemo, untrack, createSignal, DEV } from '/node_modules/.vite/deps/solid-js.js?v=53da11be';\n\nfunction createProxy(source) {\n    return new Proxy(function hmrCompWrapper(props, ...rest) {\n        const s = source();\n        if (!s || $DEVCOMP in s) {\n            return createMemo(() => {\n                const c = source();\n                if (c) {\n                    return untrack(() => c(props));\n                }\n                return undefined;\n            });\n        }\n        // no $DEVCOMP means it did not go through devComponent so source() is a regular function, not a component\n        return s.call(this, props, ...rest);\n    }, {\n        get(_, property) {\n            return source()[property];\n        },\n        set(_, property, value) {\n            source()[property] = value;\n            return true;\n        }\n    });\n}\n\nfunction isListUpdated(a, b) {\n    if (a == null && b != null) {\n        return true;\n    }\n    if (a != null && b == null) {\n        return true;\n    }\n    if (a && b) {\n        if (a.length !== b.length) {\n            return true;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (!Object.is(a[i], b[i])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nfunction hot$1({ component: Comp, id, signature, dependencies }, hot) {\n    if (hot) {\n        const [comp, setComp] = createSignal(Comp, { internal: true });\n        const prev = hot.data;\n        // Check if there's previous data\n        if (prev && prev[id]) {\n            // Check if there's a new signature and dependency\n            // This is always new in standard HMR\n            if (signature && dependencies) {\n                // Check if signature changed\n                // or dependencies changed\n                if (prev[id].signature !== signature ||\n                    isListUpdated(prev[id].dependencies, dependencies)) {\n                    // Remount\n                    prev[id].dependencies = dependencies;\n                    prev[id].signature = signature;\n                    prev[id].setComp(() => Comp);\n                }\n            }\n            else {\n                prev[id].setComp(() => Comp);\n            }\n        }\n        hot.dispose(data => {\n            data[id] = prev\n                ? prev[id]\n                : {\n                    setComp,\n                    signature,\n                    dependencies\n                };\n        });\n        hot.accept();\n        return createProxy(comp);\n    }\n    return Comp;\n}\n\nconst HOT_DATA_PREFIX = \"solid-refresh-ctx\";\nfunction hot({ component: Comp, id, signature, dependencies }, hot) {\n    let Component = Comp;\n    function handler(newModule) {\n        const registration = newModule.$$registrations[id];\n        if (!registration) {\n            // For some reason, the registration was lost, invalidate\n            return true;\n        }\n        registration.component.setComp = Comp.setComp;\n        registration.component.signature = Comp.signature;\n        registration.component.dependencies = Comp.dependencies;\n        // Check if incoming module has signature\n        if (registration.signature && registration.dependencies) {\n            // Compare old signature and dependencies\n            if (registration.signature !== Comp.signature ||\n                isListUpdated(registration.dependencies, Comp.dependencies)) {\n                // Remount\n                Comp.dependencies = registration.dependencies;\n                Comp.signature = registration.signature;\n                Comp.setComp(() => registration.component);\n            }\n        }\n        else {\n            // No granular update, remount\n            Comp.setComp(() => registration.component);\n        }\n        registration.component.signature = Comp.signature;\n        registration.component.dependencies = Comp.dependencies;\n        return false;\n    }\n    if (hot && hot.data) {\n        const refreshData = (hot.data[HOT_DATA_PREFIX] = hot.data[HOT_DATA_PREFIX] || {});\n        if (refreshData[id]) {\n            Comp.setComp = refreshData[id].Comp.setComp;\n            return { Component: refreshData[id].Component, handler };\n        }\n        const [comp, setComp] = createSignal(Comp, { internal: true });\n        Comp.setComp = setComp;\n        Comp.dependencies = dependencies;\n        Comp.signature = signature;\n        Component = createProxy(comp);\n        refreshData[id] = { Component, Comp };\n    }\n    return { Component, handler };\n}\n\nlet warned = false;\nfunction shouldWarnAndDecline() {\n    const result = DEV && Object.keys(DEV).length;\n    if (result) {\n        return false;\n    }\n    if (!warned) {\n        console.warn(\"To use solid-refresh, you need to use the dev build of SolidJS. Make sure your build system supports package.json conditional exports and has the 'development' condition turned on.\");\n        warned = true;\n    }\n    return true;\n}\n\nexport { hot as esm, shouldWarnAndDecline, hot$1 as standard };\n","start":1676889523267,"end":1676889523268,"order":"normal"}]}
