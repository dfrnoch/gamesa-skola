{"resolvedId":"C:/Users/tobis/gamesa-skola/node_modules/@tanstack/solid-query/build/solid/createBaseQuery.js?v=2f17421b","transforms":[{"name":"__load__","result":"import { useQueryClient } from './QueryClientProvider';\nimport { onMount, onCleanup, createComputed, createResource, on, batch, } from 'solid-js';\nimport { createStore, unwrap } from 'solid-js/store';\nimport { shouldThrowError } from './utils';\n// Base Query Function that is used to create the query.\nexport function createBaseQuery(options, Observer) {\n    const queryClient = useQueryClient({ context: options.context });\n    const emptyData = Symbol('empty');\n    const defaultedOptions = queryClient.defaultQueryOptions(options);\n    defaultedOptions._optimisticResults = 'optimistic';\n    const observer = new Observer(queryClient, defaultedOptions);\n    const [state, setState] = createStore(\n    // @ts-ignore\n    observer.getOptimisticResult(defaultedOptions));\n    const [dataResource, { refetch, mutate }] = createResource(() => {\n        return new Promise((resolve) => {\n            if (!(state.isFetching && state.isLoading)) {\n                if (unwrap(state.data) === emptyData) {\n                    resolve(undefined);\n                }\n                resolve(unwrap(state.data));\n            }\n        });\n    });\n    batch(() => {\n        mutate(() => unwrap(state.data));\n        refetch();\n    });\n    let taskQueue = [];\n    const unsubscribe = observer.subscribe((result) => {\n        taskQueue.push(() => {\n            batch(() => {\n                const unwrappedResult = { ...unwrap(result) };\n                if (unwrappedResult.data === undefined) {\n                    // This is a hack to prevent Solid\n                    // from deleting the data property when it is `undefined`\n                    // ref: https://www.solidjs.com/docs/latest/api#updating-stores\n                    // @ts-ignore\n                    unwrappedResult.data = emptyData;\n                }\n                setState(unwrap(unwrappedResult));\n                mutate(() => unwrap(result.data));\n                refetch();\n            });\n        });\n        queueMicrotask(() => {\n            const taskToRun = taskQueue.pop();\n            if (taskToRun) {\n                taskToRun();\n            }\n            taskQueue = [];\n        });\n    });\n    onCleanup(() => unsubscribe());\n    onMount(() => {\n        observer.setOptions(defaultedOptions, { listeners: false });\n    });\n    createComputed(() => {\n        const newDefaultedOptions = queryClient.defaultQueryOptions(options);\n        observer.setOptions(newDefaultedOptions);\n    });\n    createComputed(on(() => state.status, () => {\n        if (state.isError &&\n            !state.isFetching &&\n            shouldThrowError(observer.options.useErrorBoundary, [\n                state.error,\n                observer.getCurrentQuery(),\n            ])) {\n            throw state.error;\n        }\n    }));\n    const handler = {\n        get(target, prop) {\n            if (prop === 'data') {\n                return dataResource();\n            }\n            return Reflect.get(target, prop);\n        },\n    };\n    return new Proxy(state, handler);\n}\n","start":1676889524349,"end":1676889524349},{"name":"vite:import-analysis","result":"import { useQueryClient } from '/node_modules/@tanstack/solid-query/build/solid/QueryClientProvider.jsx?v=2f17421b';\nimport { onMount, onCleanup, createComputed, createResource, on, batch, } from '/node_modules/.vite/deps/solid-js.js?v=53da11be';\nimport { createStore, unwrap } from '/node_modules/.vite/deps/solid-js_store.js?v=53da11be';\nimport { shouldThrowError } from '/node_modules/@tanstack/solid-query/build/solid/utils.js?v=2f17421b';\n// Base Query Function that is used to create the query.\nexport function createBaseQuery(options, Observer) {\n    const queryClient = useQueryClient({ context: options.context });\n    const emptyData = Symbol('empty');\n    const defaultedOptions = queryClient.defaultQueryOptions(options);\n    defaultedOptions._optimisticResults = 'optimistic';\n    const observer = new Observer(queryClient, defaultedOptions);\n    const [state, setState] = createStore(\n    // @ts-ignore\n    observer.getOptimisticResult(defaultedOptions));\n    const [dataResource, { refetch, mutate }] = createResource(() => {\n        return new Promise((resolve) => {\n            if (!(state.isFetching && state.isLoading)) {\n                if (unwrap(state.data) === emptyData) {\n                    resolve(undefined);\n                }\n                resolve(unwrap(state.data));\n            }\n        });\n    });\n    batch(() => {\n        mutate(() => unwrap(state.data));\n        refetch();\n    });\n    let taskQueue = [];\n    const unsubscribe = observer.subscribe((result) => {\n        taskQueue.push(() => {\n            batch(() => {\n                const unwrappedResult = { ...unwrap(result) };\n                if (unwrappedResult.data === undefined) {\n                    // This is a hack to prevent Solid\n                    // from deleting the data property when it is `undefined`\n                    // ref: https://www.solidjs.com/docs/latest/api#updating-stores\n                    // @ts-ignore\n                    unwrappedResult.data = emptyData;\n                }\n                setState(unwrap(unwrappedResult));\n                mutate(() => unwrap(result.data));\n                refetch();\n            });\n        });\n        queueMicrotask(() => {\n            const taskToRun = taskQueue.pop();\n            if (taskToRun) {\n                taskToRun();\n            }\n            taskQueue = [];\n        });\n    });\n    onCleanup(() => unsubscribe());\n    onMount(() => {\n        observer.setOptions(defaultedOptions, { listeners: false });\n    });\n    createComputed(() => {\n        const newDefaultedOptions = queryClient.defaultQueryOptions(options);\n        observer.setOptions(newDefaultedOptions);\n    });\n    createComputed(on(() => state.status, () => {\n        if (state.isError &&\n            !state.isFetching &&\n            shouldThrowError(observer.options.useErrorBoundary, [\n                state.error,\n                observer.getCurrentQuery(),\n            ])) {\n            throw state.error;\n        }\n    }));\n    const handler = {\n        get(target, prop) {\n            if (prop === 'data') {\n                return dataResource();\n            }\n            return Reflect.get(target, prop);\n        },\n    };\n    return new Proxy(state, handler);\n}\n","start":1676889524349,"end":1676889524354,"order":"normal"}]}
