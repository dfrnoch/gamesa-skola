{"resolvedId":"C:/Users/tobis/gamesa-skola/node_modules/.vite/deps/@trpc_client.js?v=2ac3ed7c","transforms":[{"name":"vite:optimized-deps","result":"// node_modules/@trpc/server/dist/observable-ade1bad8.mjs\nfunction identity(x) {\n  return x;\n}\nfunction pipeFromArray(fns) {\n  if (fns.length === 0) {\n    return identity;\n  }\n  if (fns.length === 1) {\n    return fns[0];\n  }\n  return function piped(input) {\n    return fns.reduce((prev, fn) => fn(prev), input);\n  };\n}\nfunction observable(subscribe) {\n  const self = {\n    subscribe(observer) {\n      let teardownRef = null;\n      let isDone = false;\n      let unsubscribed = false;\n      let teardownImmediately = false;\n      function unsubscribe() {\n        if (teardownRef === null) {\n          teardownImmediately = true;\n          return;\n        }\n        if (unsubscribed) {\n          return;\n        }\n        unsubscribed = true;\n        if (typeof teardownRef === \"function\") {\n          teardownRef();\n        } else if (teardownRef) {\n          teardownRef.unsubscribe();\n        }\n      }\n      teardownRef = subscribe({\n        next(value) {\n          var _a;\n          if (isDone) {\n            return;\n          }\n          (_a = observer.next) == null ? void 0 : _a.call(observer, value);\n        },\n        error(err) {\n          var _a;\n          if (isDone) {\n            return;\n          }\n          isDone = true;\n          (_a = observer.error) == null ? void 0 : _a.call(observer, err);\n          unsubscribe();\n        },\n        complete() {\n          var _a;\n          if (isDone) {\n            return;\n          }\n          isDone = true;\n          (_a = observer.complete) == null ? void 0 : _a.call(observer);\n          unsubscribe();\n        }\n      });\n      if (teardownImmediately) {\n        unsubscribe();\n      }\n      return {\n        unsubscribe\n      };\n    },\n    pipe(...operations) {\n      return pipeFromArray(operations)(self);\n    }\n  };\n  return self;\n}\n\n// node_modules/@trpc/server/dist/observable/index.mjs\nfunction share(_opts) {\n  return (originalObserver) => {\n    let refCount = 0;\n    let subscription = null;\n    const observers = [];\n    function startIfNeeded() {\n      if (subscription) {\n        return;\n      }\n      subscription = originalObserver.subscribe({\n        next(value) {\n          var _a;\n          for (const observer of observers) {\n            (_a = observer.next) == null ? void 0 : _a.call(observer, value);\n          }\n        },\n        error(error) {\n          var _a;\n          for (const observer of observers) {\n            (_a = observer.error) == null ? void 0 : _a.call(observer, error);\n          }\n        },\n        complete() {\n          var _a;\n          for (const observer of observers) {\n            (_a = observer.complete) == null ? void 0 : _a.call(observer);\n          }\n        }\n      });\n    }\n    function resetIfNeeded() {\n      if (refCount === 0 && subscription) {\n        const _sub = subscription;\n        subscription = null;\n        _sub.unsubscribe();\n      }\n    }\n    return {\n      subscribe(observer) {\n        refCount++;\n        observers.push(observer);\n        startIfNeeded();\n        return {\n          unsubscribe() {\n            refCount--;\n            resetIfNeeded();\n            const index = observers.findIndex((v) => v === observer);\n            if (index > -1) {\n              observers.splice(index, 1);\n            }\n          }\n        };\n      }\n    };\n  };\n}\nfunction tap(observer) {\n  return (originalObserver) => {\n    return {\n      subscribe(observer2) {\n        return originalObserver.subscribe({\n          next(v) {\n            var _a, _b;\n            (_a = observer.next) == null ? void 0 : _a.call(observer, v);\n            (_b = observer2.next) == null ? void 0 : _b.call(observer2, v);\n          },\n          error(v) {\n            var _a, _b;\n            (_a = observer.error) == null ? void 0 : _a.call(observer, v);\n            (_b = observer2.error) == null ? void 0 : _b.call(observer2, v);\n          },\n          complete() {\n            var _a, _b;\n            (_a = observer.complete) == null ? void 0 : _a.call(observer);\n            (_b = observer2.complete) == null ? void 0 : _b.call(observer2);\n          }\n        });\n      }\n    };\n  };\n}\nvar ObservableAbortError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ObservableAbortError\";\n    Object.setPrototypeOf(this, ObservableAbortError.prototype);\n  }\n};\nfunction observableToPromise(observable2) {\n  let abort;\n  const promise = new Promise((resolve, reject) => {\n    let isDone = false;\n    function onDone() {\n      if (isDone) {\n        return;\n      }\n      isDone = true;\n      reject(new ObservableAbortError(\"This operation was aborted.\"));\n      obs$.unsubscribe();\n    }\n    const obs$ = observable2.subscribe({\n      next(data) {\n        isDone = true;\n        resolve(data);\n        onDone();\n      },\n      error(data) {\n        isDone = true;\n        reject(data);\n        onDone();\n      },\n      complete() {\n        isDone = true;\n        onDone();\n      }\n    });\n    abort = onDone;\n  });\n  return {\n    promise,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    abort\n  };\n}\n\n// node_modules/@trpc/client/dist/transformResult-6fb67924.mjs\nvar TRPCClientError = class extends Error {\n  static from(cause, opts = {}) {\n    if (!(cause instanceof Error)) {\n      return new TRPCClientError(cause.error.message ?? \"\", {\n        ...opts,\n        cause: void 0,\n        result: cause\n      });\n    }\n    if (cause.name === \"TRPCClientError\") {\n      return cause;\n    }\n    return new TRPCClientError(cause.message, {\n      ...opts,\n      cause,\n      result: null\n    });\n  }\n  constructor(message, opts) {\n    var _a, _b;\n    const cause = opts == null ? void 0 : opts.cause;\n    super(message, {\n      cause\n    });\n    this.meta = opts == null ? void 0 : opts.meta;\n    this.cause = cause;\n    this.shape = (_a = opts == null ? void 0 : opts.result) == null ? void 0 : _a.error;\n    this.data = (_b = opts == null ? void 0 : opts.result) == null ? void 0 : _b.error.data;\n    this.name = \"TRPCClientError\";\n    Object.setPrototypeOf(this, TRPCClientError.prototype);\n  }\n};\nfunction transformResultInner(response, runtime) {\n  if (\"error\" in response) {\n    const error = runtime.transformer.deserialize(response.error);\n    return {\n      ok: false,\n      error: {\n        ...response,\n        error\n      }\n    };\n  }\n  const result = {\n    ...response.result,\n    ...(!response.result.type || response.result.type === \"data\") && {\n      type: \"data\",\n      data: runtime.transformer.deserialize(response.result.data)\n    }\n  };\n  return {\n    ok: true,\n    result\n  };\n}\nfunction isObject(value) {\n  return !!value && !Array.isArray(value) && typeof value === \"object\";\n}\nfunction transformResult(response, runtime) {\n  let result;\n  try {\n    result = transformResultInner(response, runtime);\n  } catch (err) {\n    throw new TRPCClientError(\"Unable to transform response from server\");\n  }\n  if (!result.ok && (!isObject(result.error.error) || typeof result.error.error.code !== \"number\")) {\n    throw new TRPCClientError(\"Badly formatted response from server\");\n  }\n  if (result.ok && !isObject(result.result)) {\n    throw new TRPCClientError(\"Badly formatted response from server\");\n  }\n  return result;\n}\n\n// node_modules/@trpc/client/dist/splitLink-4c75f7be.mjs\nfunction createChain(opts) {\n  return observable((observer) => {\n    function execute(index = 0, op = opts.op) {\n      const next = opts.links[index];\n      if (!next) {\n        throw new Error(\"No more links to execute - did you forget to add an ending link?\");\n      }\n      const subscription = next({\n        op,\n        next(nextOp) {\n          const nextObserver = execute(index + 1, nextOp);\n          return nextObserver;\n        }\n      });\n      return subscription;\n    }\n    const obs$ = execute();\n    return obs$.subscribe(observer);\n  });\n}\nfunction asArray(value) {\n  return Array.isArray(value) ? value : [\n    value\n  ];\n}\nfunction splitLink(opts) {\n  return (runtime) => {\n    const yes = asArray(opts.true).map((link) => link(runtime));\n    const no = asArray(opts.false).map((link) => link(runtime));\n    return (props) => {\n      return observable((observer) => {\n        const links = opts.condition(props.op) ? yes : no;\n        return createChain({\n          op: props.op,\n          links\n        }).subscribe(observer);\n      });\n    };\n  };\n}\n\n// node_modules/@trpc/server/dist/index-972002da.mjs\nvar noop = () => {\n};\nfunction createInnerProxy(callback, path) {\n  const proxy = new Proxy(noop, {\n    get(_obj, key) {\n      if (typeof key !== \"string\" || key === \"then\") {\n        return void 0;\n      }\n      return createInnerProxy(callback, [\n        ...path,\n        key\n      ]);\n    },\n    apply(_1, _2, args) {\n      return callback({\n        args,\n        path\n      });\n    }\n  });\n  return proxy;\n}\nvar createRecursiveProxy = (callback) => createInnerProxy(callback, []);\nvar createFlatProxy = (callback) => {\n  return new Proxy(noop, {\n    get(_obj, name) {\n      if (typeof name !== \"string\" || name === \"then\") {\n        return void 0;\n      }\n      return callback(name);\n    }\n  });\n};\n\n// node_modules/@trpc/client/dist/httpUtils-9322dc79.mjs\nfunction getWindow() {\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  return globalThis;\n}\nfunction getAbortController(ac) {\n  return ac ?? getWindow().AbortController ?? null;\n}\nfunction getFetch(f) {\n  if (f) {\n    return f;\n  }\n  const win = getWindow();\n  const globalFetch = win.fetch;\n  if (globalFetch) {\n    return typeof globalFetch.bind === \"function\" ? globalFetch.bind(win) : globalFetch;\n  }\n  throw new Error(\"No fetch implementation found\");\n}\nfunction resolveHTTPLinkOptions(opts) {\n  const headers = opts.headers || (() => ({}));\n  return {\n    url: opts.url,\n    fetch: getFetch(opts.fetch),\n    AbortController: getAbortController(opts.AbortController),\n    headers: typeof headers === \"function\" ? headers : () => headers\n  };\n}\nfunction arrayToDict(array) {\n  const dict = {};\n  for (let index = 0; index < array.length; index++) {\n    const element = array[index];\n    dict[index] = element;\n  }\n  return dict;\n}\nvar METHOD = {\n  query: \"GET\",\n  mutation: \"POST\"\n};\nfunction getInput(opts) {\n  return \"input\" in opts ? opts.runtime.transformer.serialize(opts.input) : arrayToDict(opts.inputs.map((_input) => opts.runtime.transformer.serialize(_input)));\n}\nfunction getUrl(opts) {\n  let url = opts.url + \"/\" + opts.path;\n  const queryParts = [];\n  if (\"inputs\" in opts) {\n    queryParts.push(\"batch=1\");\n  }\n  if (opts.type === \"query\") {\n    const input = getInput(opts);\n    if (input !== void 0) {\n      queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);\n    }\n  }\n  if (queryParts.length) {\n    url += \"?\" + queryParts.join(\"&\");\n  }\n  return url;\n}\nfunction getBody(opts) {\n  if (opts.type === \"query\") {\n    return void 0;\n  }\n  const input = getInput(opts);\n  return input !== void 0 ? JSON.stringify(input) : void 0;\n}\nfunction httpRequest(opts) {\n  const { type } = opts;\n  const ac = opts.AbortController ? new opts.AbortController() : null;\n  const promise = new Promise((resolve, reject) => {\n    const url = getUrl(opts);\n    const body = getBody(opts);\n    const meta = {};\n    Promise.resolve(opts.headers()).then((headers) => {\n      if (type === \"subscription\") {\n        throw new Error(\"Subscriptions should use wsLink\");\n      }\n      return opts.fetch(url, {\n        method: METHOD[type],\n        signal: ac == null ? void 0 : ac.signal,\n        body,\n        headers: {\n          \"content-type\": \"application/json\",\n          ...headers\n        }\n      });\n    }).then((_res) => {\n      meta.response = _res;\n      return _res.json();\n    }).then((json) => {\n      resolve({\n        json,\n        meta\n      });\n    }).catch(reject);\n  });\n  const cancel = () => {\n    ac == null ? void 0 : ac.abort();\n  };\n  return {\n    promise,\n    cancel\n  };\n}\n\n// node_modules/@trpc/client/dist/links/httpBatchLink.mjs\nvar throwFatalError = () => {\n  throw new Error(\"Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new\");\n};\nfunction dataLoader(batchLoader) {\n  let pendingItems = null;\n  let dispatchTimer = null;\n  const destroyTimerAndPendingItems = () => {\n    clearTimeout(dispatchTimer);\n    dispatchTimer = null;\n    pendingItems = null;\n  };\n  function groupItems(items) {\n    const groupedItems = [\n      []\n    ];\n    let index = 0;\n    while (true) {\n      const item = items[index];\n      if (!item) {\n        break;\n      }\n      const lastGroup = groupedItems[groupedItems.length - 1];\n      if (item.aborted) {\n        item.reject(new Error(\"Aborted\"));\n        index++;\n        continue;\n      }\n      const isValid = batchLoader.validate(lastGroup.concat(item).map((it) => it.key));\n      if (isValid) {\n        lastGroup.push(item);\n        index++;\n        continue;\n      }\n      if (lastGroup.length === 0) {\n        item.reject(new Error(\"Input is too big for a single dispatch\"));\n        index++;\n        continue;\n      }\n      groupedItems.push([]);\n    }\n    return groupedItems;\n  }\n  function dispatch() {\n    const groupedItems = groupItems(pendingItems);\n    destroyTimerAndPendingItems();\n    for (const items of groupedItems) {\n      if (!items.length) {\n        continue;\n      }\n      const batch = {\n        items,\n        cancel: throwFatalError\n      };\n      for (const item of items) {\n        item.batch = batch;\n      }\n      const { promise, cancel } = batchLoader.fetch(batch.items.map((_item) => _item.key));\n      batch.cancel = cancel;\n      promise.then((result) => {\n        for (let i = 0; i < result.length; i++) {\n          const value = result[i];\n          const item = batch.items[i];\n          item.resolve(value);\n          item.batch = null;\n        }\n      }).catch((cause) => {\n        for (const item of batch.items) {\n          item.reject(cause);\n          item.batch = null;\n        }\n      });\n    }\n  }\n  function load(key) {\n    const item = {\n      aborted: false,\n      key,\n      batch: null,\n      resolve: throwFatalError,\n      reject: throwFatalError\n    };\n    const promise = new Promise((resolve, reject) => {\n      item.reject = reject;\n      item.resolve = resolve;\n      if (!pendingItems) {\n        pendingItems = [];\n      }\n      pendingItems.push(item);\n    });\n    if (!dispatchTimer) {\n      dispatchTimer = setTimeout(dispatch);\n    }\n    const cancel = () => {\n      var _a;\n      item.aborted = true;\n      if ((_a = item.batch) == null ? void 0 : _a.items.every((item2) => item2.aborted)) {\n        item.batch.cancel();\n        item.batch = null;\n      }\n    };\n    return {\n      promise,\n      cancel\n    };\n  }\n  return {\n    load\n  };\n}\nfunction httpBatchLink(opts) {\n  const resolvedOpts = resolveHTTPLinkOptions(opts);\n  return (runtime) => {\n    const maxURLLength = opts.maxURLLength || Infinity;\n    const batchLoader = (type) => {\n      const validate = (batchOps) => {\n        if (maxURLLength === Infinity) {\n          return true;\n        }\n        const path = batchOps.map((op) => op.path).join(\",\");\n        const inputs = batchOps.map((op) => op.input);\n        const url = getUrl({\n          ...resolvedOpts,\n          runtime,\n          type,\n          path,\n          inputs\n        });\n        return url.length <= maxURLLength;\n      };\n      const fetch = (batchOps) => {\n        const path = batchOps.map((op) => op.path).join(\",\");\n        const inputs = batchOps.map((op) => op.input);\n        const { promise, cancel } = httpRequest({\n          ...resolvedOpts,\n          runtime,\n          type,\n          path,\n          inputs\n        });\n        return {\n          promise: promise.then((res) => {\n            const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(() => res.json);\n            const result = resJSON.map((item) => ({\n              meta: res.meta,\n              json: item\n            }));\n            return result;\n          }),\n          cancel\n        };\n      };\n      return {\n        validate,\n        fetch\n      };\n    };\n    const query = dataLoader(batchLoader(\"query\"));\n    const mutation = dataLoader(batchLoader(\"mutation\"));\n    const subscription = dataLoader(batchLoader(\"subscription\"));\n    const loaders = {\n      query,\n      subscription,\n      mutation\n    };\n    return ({ op }) => {\n      return observable((observer) => {\n        const loader = loaders[op.type];\n        const { promise, cancel } = loader.load(op);\n        promise.then((res) => {\n          const transformed = transformResult(res.json, runtime);\n          if (!transformed.ok) {\n            observer.error(TRPCClientError.from(transformed.error, {\n              meta: res.meta\n            }));\n            return;\n          }\n          observer.next({\n            context: res.meta,\n            result: transformed.result\n          });\n          observer.complete();\n        }).catch((err) => observer.error(TRPCClientError.from(err)));\n        return () => {\n          cancel();\n        };\n      });\n    };\n  };\n}\n\n// node_modules/@trpc/client/dist/links/httpLink.mjs\nfunction httpLink(opts) {\n  const resolvedOpts = resolveHTTPLinkOptions(opts);\n  return (runtime) => ({ op }) => observable((observer) => {\n    const { path, input, type } = op;\n    const { promise, cancel } = httpRequest({\n      ...resolvedOpts,\n      runtime,\n      type,\n      path,\n      input\n    });\n    promise.then((res) => {\n      const transformed = transformResult(res.json, runtime);\n      if (!transformed.ok) {\n        observer.error(TRPCClientError.from(transformed.error, {\n          meta: res.meta\n        }));\n        return;\n      }\n      observer.next({\n        context: res.meta,\n        result: transformed.result\n      });\n      observer.complete();\n    }).catch((cause) => observer.error(TRPCClientError.from(cause)));\n    return () => {\n      cancel();\n    };\n  });\n}\n\n// node_modules/@trpc/client/dist/links/loggerLink.mjs\nvar palette = {\n  query: [\n    \"72e3ff\",\n    \"3fb0d8\"\n  ],\n  mutation: [\n    \"c5a3fc\",\n    \"904dfc\"\n  ],\n  subscription: [\n    \"ff49e1\",\n    \"d83fbe\"\n  ]\n};\nvar defaultLogger = (c = console) => (props) => {\n  const { direction, input, type, path, context, id } = props;\n  const [light, dark] = palette[type];\n  const css = `\n    background-color: #${direction === \"up\" ? light : dark}; \n    color: ${direction === \"up\" ? \"black\" : \"white\"};\n    padding: 2px;\n  `;\n  const parts = [\n    \"%c\",\n    direction === \"up\" ? \">>\" : \"<<\",\n    type,\n    `#${id}`,\n    `%c${path}%c`,\n    \"%O\"\n  ];\n  const args = [\n    css,\n    `${css}; font-weight: bold;`,\n    `${css}; font-weight: normal;`\n  ];\n  if (props.direction === \"up\") {\n    args.push({\n      input,\n      context\n    });\n  } else {\n    args.push({\n      input,\n      result: props.result,\n      elapsedMs: props.elapsedMs,\n      context\n    });\n  }\n  const fn = props.direction === \"down\" && props.result && (props.result instanceof Error || \"error\" in props.result.result) ? \"error\" : \"log\";\n  c[fn].apply(null, [\n    parts.join(\" \")\n  ].concat(args));\n};\nfunction loggerLink(opts = {}) {\n  const { enabled = () => true } = opts;\n  const { logger = defaultLogger(opts.console) } = opts;\n  return () => {\n    return ({ op, next }) => {\n      return observable((observer) => {\n        enabled({\n          ...op,\n          direction: \"up\"\n        }) && logger({\n          ...op,\n          direction: \"up\"\n        });\n        const requestStartTime = Date.now();\n        function logResult(result) {\n          const elapsedMs = Date.now() - requestStartTime;\n          enabled({\n            ...op,\n            direction: \"down\",\n            result\n          }) && logger({\n            ...op,\n            direction: \"down\",\n            elapsedMs,\n            result\n          });\n        }\n        return next(op).pipe(tap({\n          next(result) {\n            logResult(result);\n          },\n          error(result) {\n            logResult(result);\n          }\n        })).subscribe(observer);\n      });\n    };\n  };\n}\n\n// node_modules/@trpc/client/dist/links/wsLink.mjs\nvar retryDelay = (attemptIndex) => attemptIndex === 0 ? 0 : Math.min(1e3 * 2 ** attemptIndex, 3e4);\nfunction createWSClient(opts) {\n  const { url, WebSocket: WebSocketImpl = WebSocket, retryDelayMs: retryDelayFn = retryDelay, onOpen, onClose } = opts;\n  if (!WebSocketImpl) {\n    throw new Error(\"No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill\");\n  }\n  let outgoing = [];\n  const pendingRequests = /* @__PURE__ */ Object.create(null);\n  let connectAttempt = 0;\n  let dispatchTimer = null;\n  let connectTimer = null;\n  let activeConnection = createWS();\n  let state = \"connecting\";\n  function dispatch() {\n    if (state !== \"open\" || dispatchTimer) {\n      return;\n    }\n    dispatchTimer = setTimeout(() => {\n      dispatchTimer = null;\n      if (outgoing.length === 1) {\n        activeConnection.send(JSON.stringify(outgoing.pop()));\n      } else {\n        activeConnection.send(JSON.stringify(outgoing));\n      }\n      outgoing = [];\n    });\n  }\n  function tryReconnect() {\n    if (connectTimer || state === \"closed\") {\n      return;\n    }\n    const timeout = retryDelayFn(connectAttempt++);\n    reconnectInMs(timeout);\n  }\n  function reconnect() {\n    state = \"connecting\";\n    const oldConnection = activeConnection;\n    activeConnection = createWS();\n    closeIfNoPending(oldConnection);\n  }\n  function reconnectInMs(ms) {\n    if (connectTimer) {\n      return;\n    }\n    state = \"connecting\";\n    connectTimer = setTimeout(reconnect, ms);\n  }\n  function closeIfNoPending(conn) {\n    const hasPendingRequests = Object.values(pendingRequests).some((p) => p.ws === conn);\n    if (!hasPendingRequests) {\n      conn.close();\n    }\n  }\n  function resumeSubscriptionOnReconnect(req) {\n    if (outgoing.some((r) => r.id === req.op.id)) {\n      return;\n    }\n    request(req.op, req.callbacks);\n  }\n  function createWS() {\n    const urlString = typeof url === \"function\" ? url() : url;\n    const conn = new WebSocketImpl(urlString);\n    clearTimeout(connectTimer);\n    connectTimer = null;\n    conn.addEventListener(\"open\", () => {\n      if (conn !== activeConnection) {\n        return;\n      }\n      connectAttempt = 0;\n      state = \"open\";\n      onOpen == null ? void 0 : onOpen();\n      dispatch();\n    });\n    conn.addEventListener(\"error\", () => {\n      if (conn === activeConnection) {\n        tryReconnect();\n      }\n    });\n    const handleIncomingRequest = (req) => {\n      if (req.method === \"reconnect\" && conn === activeConnection) {\n        if (state === \"open\") {\n          onClose == null ? void 0 : onClose();\n        }\n        reconnect();\n        for (const pendingReq of Object.values(pendingRequests)) {\n          if (pendingReq.type === \"subscription\") {\n            resumeSubscriptionOnReconnect(pendingReq);\n          }\n        }\n      }\n    };\n    const handleIncomingResponse = (data) => {\n      var _a, _b;\n      const req = data.id !== null && pendingRequests[data.id];\n      if (!req) {\n        return;\n      }\n      (_b = (_a = req.callbacks).next) == null ? void 0 : _b.call(_a, data);\n      if (req.ws !== activeConnection && conn === activeConnection) {\n        const oldWs = req.ws;\n        req.ws = activeConnection;\n        closeIfNoPending(oldWs);\n      }\n      if (\"result\" in data && data.result.type === \"stopped\" && conn === activeConnection) {\n        req.callbacks.complete();\n      }\n    };\n    conn.addEventListener(\"message\", ({ data }) => {\n      const msg = JSON.parse(data);\n      if (\"method\" in msg) {\n        handleIncomingRequest(msg);\n      } else {\n        handleIncomingResponse(msg);\n      }\n      if (conn !== activeConnection || state === \"closed\") {\n        closeIfNoPending(conn);\n      }\n    });\n    conn.addEventListener(\"close\", ({ code }) => {\n      var _a, _b, _c, _d;\n      if (state === \"open\") {\n        onClose == null ? void 0 : onClose({\n          code\n        });\n      }\n      if (activeConnection === conn) {\n        tryReconnect();\n      }\n      for (const [key, req] of Object.entries(pendingRequests)) {\n        if (req.ws !== conn) {\n          continue;\n        }\n        if (state === \"closed\") {\n          delete pendingRequests[key];\n          (_b = (_a = req.callbacks).complete) == null ? void 0 : _b.call(_a);\n          continue;\n        }\n        if (req.type === \"subscription\") {\n          resumeSubscriptionOnReconnect(req);\n        } else {\n          delete pendingRequests[key];\n          (_d = (_c = req.callbacks).error) == null ? void 0 : _d.call(_c, TRPCClientError.from(new TRPCWebSocketClosedError(\"WebSocket closed prematurely\")));\n        }\n      }\n    });\n    return conn;\n  }\n  function request(op, callbacks) {\n    const { type, input, path, id } = op;\n    const envelope = {\n      id,\n      method: type,\n      params: {\n        input,\n        path\n      }\n    };\n    pendingRequests[id] = {\n      ws: activeConnection,\n      type,\n      callbacks,\n      op\n    };\n    outgoing.push(envelope);\n    dispatch();\n    return () => {\n      var _a, _b;\n      const callbacks2 = (_a = pendingRequests[id]) == null ? void 0 : _a.callbacks;\n      delete pendingRequests[id];\n      outgoing = outgoing.filter((msg) => msg.id !== id);\n      (_b = callbacks2 == null ? void 0 : callbacks2.complete) == null ? void 0 : _b.call(callbacks2);\n      if (activeConnection.readyState === WebSocketImpl.OPEN && op.type === \"subscription\") {\n        outgoing.push({\n          id,\n          method: \"subscription.stop\"\n        });\n        dispatch();\n      }\n    };\n  }\n  return {\n    close: () => {\n      state = \"closed\";\n      onClose == null ? void 0 : onClose();\n      closeIfNoPending(activeConnection);\n      clearTimeout(connectTimer);\n      connectTimer = null;\n    },\n    request,\n    getConnection() {\n      return activeConnection;\n    }\n  };\n}\nvar TRPCWebSocketClosedError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"TRPCWebSocketClosedError\";\n    Object.setPrototypeOf(this, TRPCWebSocketClosedError.prototype);\n  }\n};\nvar TRPCSubscriptionEndedError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"TRPCSubscriptionEndedError\";\n    Object.setPrototypeOf(this, TRPCSubscriptionEndedError.prototype);\n  }\n};\nfunction wsLink(opts) {\n  return (runtime) => {\n    const { client } = opts;\n    return ({ op }) => {\n      return observable((observer) => {\n        const { type, path, id, context } = op;\n        const input = runtime.transformer.serialize(op.input);\n        let isDone = false;\n        const unsub = client.request({\n          type,\n          path,\n          input,\n          id,\n          context\n        }, {\n          error(err) {\n            isDone = true;\n            observer.error(err);\n            unsub();\n          },\n          complete() {\n            if (!isDone) {\n              isDone = true;\n              observer.error(TRPCClientError.from(new TRPCSubscriptionEndedError(\"Operation ended prematurely\")));\n            } else {\n              observer.complete();\n            }\n          },\n          next(message) {\n            const transformed = transformResult(message, runtime);\n            if (!transformed.ok) {\n              observer.error(TRPCClientError.from(transformed.error));\n              return;\n            }\n            observer.next({\n              result: transformed.result\n            });\n            if (op.type !== \"subscription\") {\n              isDone = true;\n              unsub();\n              observer.complete();\n            }\n          }\n        });\n        return () => {\n          isDone = true;\n          unsub();\n        };\n      });\n    };\n  };\n}\n\n// node_modules/@trpc/client/dist/index.mjs\nvar TRPCUntypedClient = class {\n  $request({ type, input, path, context = {} }) {\n    const chain$ = createChain({\n      links: this.links,\n      op: {\n        id: ++this.requestId,\n        type,\n        path,\n        input,\n        context\n      }\n    });\n    return chain$.pipe(share());\n  }\n  requestAsPromise(opts) {\n    const req$ = this.$request(opts);\n    const { promise, abort } = observableToPromise(req$);\n    const abortablePromise = new Promise((resolve, reject) => {\n      var _a;\n      (_a = opts.signal) == null ? void 0 : _a.addEventListener(\"abort\", abort);\n      promise.then((envelope) => {\n        resolve(envelope.result.data);\n      }).catch((err) => {\n        reject(TRPCClientError.from(err));\n      });\n    });\n    return abortablePromise;\n  }\n  query(path, input, opts) {\n    return this.requestAsPromise({\n      type: \"query\",\n      path,\n      input,\n      context: opts == null ? void 0 : opts.context,\n      signal: opts == null ? void 0 : opts.signal\n    });\n  }\n  mutation(path, input, opts) {\n    return this.requestAsPromise({\n      type: \"mutation\",\n      path,\n      input,\n      context: opts == null ? void 0 : opts.context,\n      signal: opts == null ? void 0 : opts.signal\n    });\n  }\n  subscription(path, input, opts) {\n    const observable$ = this.$request({\n      type: \"subscription\",\n      path,\n      input,\n      context: opts == null ? void 0 : opts.context\n    });\n    return observable$.subscribe({\n      next(envelope) {\n        var _a, _b, _c;\n        if (envelope.result.type === \"started\") {\n          (_a = opts.onStarted) == null ? void 0 : _a.call(opts);\n        } else if (envelope.result.type === \"stopped\") {\n          (_b = opts.onStopped) == null ? void 0 : _b.call(opts);\n        } else {\n          (_c = opts.onData) == null ? void 0 : _c.call(opts, envelope.result.data);\n        }\n      },\n      error(err) {\n        var _a;\n        (_a = opts.onError) == null ? void 0 : _a.call(opts, err);\n      },\n      complete() {\n        var _a;\n        (_a = opts.onComplete) == null ? void 0 : _a.call(opts);\n      }\n    });\n  }\n  constructor(opts) {\n    this.requestId = 0;\n    function getTransformer() {\n      const transformer = opts.transformer;\n      if (!transformer)\n        return {\n          serialize: (data) => data,\n          deserialize: (data) => data\n        };\n      if (\"input\" in transformer)\n        return {\n          serialize: transformer.input.serialize,\n          deserialize: transformer.output.deserialize\n        };\n      return transformer;\n    }\n    this.runtime = {\n      transformer: getTransformer()\n    };\n    this.links = opts.links.map((link) => link(this.runtime));\n  }\n};\nfunction createTRPCUntypedClient(opts) {\n  const client = new TRPCUntypedClient(opts);\n  return client;\n}\nfunction createTRPCClient(opts) {\n  const client = new TRPCUntypedClient(opts);\n  return client;\n}\nvar clientCallTypeMap = {\n  query: \"query\",\n  mutate: \"mutation\",\n  subscribe: \"subscription\"\n};\nfunction createTRPCClientProxy(client) {\n  return createFlatProxy((key) => {\n    if (client.hasOwnProperty(key)) {\n      return client[key];\n    }\n    return createRecursiveProxy(({ path, args }) => {\n      const pathCopy = [\n        key,\n        ...path\n      ];\n      const clientCallType = pathCopy.pop();\n      const procedureType = clientCallTypeMap[clientCallType];\n      const fullPath = pathCopy.join(\".\");\n      return client[procedureType](fullPath, ...args);\n    });\n  });\n}\nfunction createTRPCProxyClient(opts) {\n  const client = new TRPCUntypedClient(opts);\n  const proxy = createTRPCClientProxy(client);\n  return proxy;\n}\nexport {\n  TRPCClientError,\n  createTRPCClient,\n  createTRPCClientProxy,\n  createTRPCProxyClient,\n  createTRPCUntypedClient,\n  createWSClient,\n  getFetch,\n  httpBatchLink,\n  httpLink,\n  loggerLink,\n  splitLink,\n  wsLink\n};\n//# sourceMappingURL=@trpc_client.js.map\n","start":1676889523775,"end":1676889525529},{"name":"vite:import-analysis","result":"// node_modules/@trpc/server/dist/observable-ade1bad8.mjs\nfunction identity(x) {\n  return x;\n}\nfunction pipeFromArray(fns) {\n  if (fns.length === 0) {\n    return identity;\n  }\n  if (fns.length === 1) {\n    return fns[0];\n  }\n  return function piped(input) {\n    return fns.reduce((prev, fn) => fn(prev), input);\n  };\n}\nfunction observable(subscribe) {\n  const self = {\n    subscribe(observer) {\n      let teardownRef = null;\n      let isDone = false;\n      let unsubscribed = false;\n      let teardownImmediately = false;\n      function unsubscribe() {\n        if (teardownRef === null) {\n          teardownImmediately = true;\n          return;\n        }\n        if (unsubscribed) {\n          return;\n        }\n        unsubscribed = true;\n        if (typeof teardownRef === \"function\") {\n          teardownRef();\n        } else if (teardownRef) {\n          teardownRef.unsubscribe();\n        }\n      }\n      teardownRef = subscribe({\n        next(value) {\n          var _a;\n          if (isDone) {\n            return;\n          }\n          (_a = observer.next) == null ? void 0 : _a.call(observer, value);\n        },\n        error(err) {\n          var _a;\n          if (isDone) {\n            return;\n          }\n          isDone = true;\n          (_a = observer.error) == null ? void 0 : _a.call(observer, err);\n          unsubscribe();\n        },\n        complete() {\n          var _a;\n          if (isDone) {\n            return;\n          }\n          isDone = true;\n          (_a = observer.complete) == null ? void 0 : _a.call(observer);\n          unsubscribe();\n        }\n      });\n      if (teardownImmediately) {\n        unsubscribe();\n      }\n      return {\n        unsubscribe\n      };\n    },\n    pipe(...operations) {\n      return pipeFromArray(operations)(self);\n    }\n  };\n  return self;\n}\n\n// node_modules/@trpc/server/dist/observable/index.mjs\nfunction share(_opts) {\n  return (originalObserver) => {\n    let refCount = 0;\n    let subscription = null;\n    const observers = [];\n    function startIfNeeded() {\n      if (subscription) {\n        return;\n      }\n      subscription = originalObserver.subscribe({\n        next(value) {\n          var _a;\n          for (const observer of observers) {\n            (_a = observer.next) == null ? void 0 : _a.call(observer, value);\n          }\n        },\n        error(error) {\n          var _a;\n          for (const observer of observers) {\n            (_a = observer.error) == null ? void 0 : _a.call(observer, error);\n          }\n        },\n        complete() {\n          var _a;\n          for (const observer of observers) {\n            (_a = observer.complete) == null ? void 0 : _a.call(observer);\n          }\n        }\n      });\n    }\n    function resetIfNeeded() {\n      if (refCount === 0 && subscription) {\n        const _sub = subscription;\n        subscription = null;\n        _sub.unsubscribe();\n      }\n    }\n    return {\n      subscribe(observer) {\n        refCount++;\n        observers.push(observer);\n        startIfNeeded();\n        return {\n          unsubscribe() {\n            refCount--;\n            resetIfNeeded();\n            const index = observers.findIndex((v) => v === observer);\n            if (index > -1) {\n              observers.splice(index, 1);\n            }\n          }\n        };\n      }\n    };\n  };\n}\nfunction tap(observer) {\n  return (originalObserver) => {\n    return {\n      subscribe(observer2) {\n        return originalObserver.subscribe({\n          next(v) {\n            var _a, _b;\n            (_a = observer.next) == null ? void 0 : _a.call(observer, v);\n            (_b = observer2.next) == null ? void 0 : _b.call(observer2, v);\n          },\n          error(v) {\n            var _a, _b;\n            (_a = observer.error) == null ? void 0 : _a.call(observer, v);\n            (_b = observer2.error) == null ? void 0 : _b.call(observer2, v);\n          },\n          complete() {\n            var _a, _b;\n            (_a = observer.complete) == null ? void 0 : _a.call(observer);\n            (_b = observer2.complete) == null ? void 0 : _b.call(observer2);\n          }\n        });\n      }\n    };\n  };\n}\nvar ObservableAbortError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ObservableAbortError\";\n    Object.setPrototypeOf(this, ObservableAbortError.prototype);\n  }\n};\nfunction observableToPromise(observable2) {\n  let abort;\n  const promise = new Promise((resolve, reject) => {\n    let isDone = false;\n    function onDone() {\n      if (isDone) {\n        return;\n      }\n      isDone = true;\n      reject(new ObservableAbortError(\"This operation was aborted.\"));\n      obs$.unsubscribe();\n    }\n    const obs$ = observable2.subscribe({\n      next(data) {\n        isDone = true;\n        resolve(data);\n        onDone();\n      },\n      error(data) {\n        isDone = true;\n        reject(data);\n        onDone();\n      },\n      complete() {\n        isDone = true;\n        onDone();\n      }\n    });\n    abort = onDone;\n  });\n  return {\n    promise,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    abort\n  };\n}\n\n// node_modules/@trpc/client/dist/transformResult-6fb67924.mjs\nvar TRPCClientError = class extends Error {\n  static from(cause, opts = {}) {\n    if (!(cause instanceof Error)) {\n      return new TRPCClientError(cause.error.message ?? \"\", {\n        ...opts,\n        cause: void 0,\n        result: cause\n      });\n    }\n    if (cause.name === \"TRPCClientError\") {\n      return cause;\n    }\n    return new TRPCClientError(cause.message, {\n      ...opts,\n      cause,\n      result: null\n    });\n  }\n  constructor(message, opts) {\n    var _a, _b;\n    const cause = opts == null ? void 0 : opts.cause;\n    super(message, {\n      cause\n    });\n    this.meta = opts == null ? void 0 : opts.meta;\n    this.cause = cause;\n    this.shape = (_a = opts == null ? void 0 : opts.result) == null ? void 0 : _a.error;\n    this.data = (_b = opts == null ? void 0 : opts.result) == null ? void 0 : _b.error.data;\n    this.name = \"TRPCClientError\";\n    Object.setPrototypeOf(this, TRPCClientError.prototype);\n  }\n};\nfunction transformResultInner(response, runtime) {\n  if (\"error\" in response) {\n    const error = runtime.transformer.deserialize(response.error);\n    return {\n      ok: false,\n      error: {\n        ...response,\n        error\n      }\n    };\n  }\n  const result = {\n    ...response.result,\n    ...(!response.result.type || response.result.type === \"data\") && {\n      type: \"data\",\n      data: runtime.transformer.deserialize(response.result.data)\n    }\n  };\n  return {\n    ok: true,\n    result\n  };\n}\nfunction isObject(value) {\n  return !!value && !Array.isArray(value) && typeof value === \"object\";\n}\nfunction transformResult(response, runtime) {\n  let result;\n  try {\n    result = transformResultInner(response, runtime);\n  } catch (err) {\n    throw new TRPCClientError(\"Unable to transform response from server\");\n  }\n  if (!result.ok && (!isObject(result.error.error) || typeof result.error.error.code !== \"number\")) {\n    throw new TRPCClientError(\"Badly formatted response from server\");\n  }\n  if (result.ok && !isObject(result.result)) {\n    throw new TRPCClientError(\"Badly formatted response from server\");\n  }\n  return result;\n}\n\n// node_modules/@trpc/client/dist/splitLink-4c75f7be.mjs\nfunction createChain(opts) {\n  return observable((observer) => {\n    function execute(index = 0, op = opts.op) {\n      const next = opts.links[index];\n      if (!next) {\n        throw new Error(\"No more links to execute - did you forget to add an ending link?\");\n      }\n      const subscription = next({\n        op,\n        next(nextOp) {\n          const nextObserver = execute(index + 1, nextOp);\n          return nextObserver;\n        }\n      });\n      return subscription;\n    }\n    const obs$ = execute();\n    return obs$.subscribe(observer);\n  });\n}\nfunction asArray(value) {\n  return Array.isArray(value) ? value : [\n    value\n  ];\n}\nfunction splitLink(opts) {\n  return (runtime) => {\n    const yes = asArray(opts.true).map((link) => link(runtime));\n    const no = asArray(opts.false).map((link) => link(runtime));\n    return (props) => {\n      return observable((observer) => {\n        const links = opts.condition(props.op) ? yes : no;\n        return createChain({\n          op: props.op,\n          links\n        }).subscribe(observer);\n      });\n    };\n  };\n}\n\n// node_modules/@trpc/server/dist/index-972002da.mjs\nvar noop = () => {\n};\nfunction createInnerProxy(callback, path) {\n  const proxy = new Proxy(noop, {\n    get(_obj, key) {\n      if (typeof key !== \"string\" || key === \"then\") {\n        return void 0;\n      }\n      return createInnerProxy(callback, [\n        ...path,\n        key\n      ]);\n    },\n    apply(_1, _2, args) {\n      return callback({\n        args,\n        path\n      });\n    }\n  });\n  return proxy;\n}\nvar createRecursiveProxy = (callback) => createInnerProxy(callback, []);\nvar createFlatProxy = (callback) => {\n  return new Proxy(noop, {\n    get(_obj, name) {\n      if (typeof name !== \"string\" || name === \"then\") {\n        return void 0;\n      }\n      return callback(name);\n    }\n  });\n};\n\n// node_modules/@trpc/client/dist/httpUtils-9322dc79.mjs\nfunction getWindow() {\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  return globalThis;\n}\nfunction getAbortController(ac) {\n  return ac ?? getWindow().AbortController ?? null;\n}\nfunction getFetch(f) {\n  if (f) {\n    return f;\n  }\n  const win = getWindow();\n  const globalFetch = win.fetch;\n  if (globalFetch) {\n    return typeof globalFetch.bind === \"function\" ? globalFetch.bind(win) : globalFetch;\n  }\n  throw new Error(\"No fetch implementation found\");\n}\nfunction resolveHTTPLinkOptions(opts) {\n  const headers = opts.headers || (() => ({}));\n  return {\n    url: opts.url,\n    fetch: getFetch(opts.fetch),\n    AbortController: getAbortController(opts.AbortController),\n    headers: typeof headers === \"function\" ? headers : () => headers\n  };\n}\nfunction arrayToDict(array) {\n  const dict = {};\n  for (let index = 0; index < array.length; index++) {\n    const element = array[index];\n    dict[index] = element;\n  }\n  return dict;\n}\nvar METHOD = {\n  query: \"GET\",\n  mutation: \"POST\"\n};\nfunction getInput(opts) {\n  return \"input\" in opts ? opts.runtime.transformer.serialize(opts.input) : arrayToDict(opts.inputs.map((_input) => opts.runtime.transformer.serialize(_input)));\n}\nfunction getUrl(opts) {\n  let url = opts.url + \"/\" + opts.path;\n  const queryParts = [];\n  if (\"inputs\" in opts) {\n    queryParts.push(\"batch=1\");\n  }\n  if (opts.type === \"query\") {\n    const input = getInput(opts);\n    if (input !== void 0) {\n      queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);\n    }\n  }\n  if (queryParts.length) {\n    url += \"?\" + queryParts.join(\"&\");\n  }\n  return url;\n}\nfunction getBody(opts) {\n  if (opts.type === \"query\") {\n    return void 0;\n  }\n  const input = getInput(opts);\n  return input !== void 0 ? JSON.stringify(input) : void 0;\n}\nfunction httpRequest(opts) {\n  const { type } = opts;\n  const ac = opts.AbortController ? new opts.AbortController() : null;\n  const promise = new Promise((resolve, reject) => {\n    const url = getUrl(opts);\n    const body = getBody(opts);\n    const meta = {};\n    Promise.resolve(opts.headers()).then((headers) => {\n      if (type === \"subscription\") {\n        throw new Error(\"Subscriptions should use wsLink\");\n      }\n      return opts.fetch(url, {\n        method: METHOD[type],\n        signal: ac == null ? void 0 : ac.signal,\n        body,\n        headers: {\n          \"content-type\": \"application/json\",\n          ...headers\n        }\n      });\n    }).then((_res) => {\n      meta.response = _res;\n      return _res.json();\n    }).then((json) => {\n      resolve({\n        json,\n        meta\n      });\n    }).catch(reject);\n  });\n  const cancel = () => {\n    ac == null ? void 0 : ac.abort();\n  };\n  return {\n    promise,\n    cancel\n  };\n}\n\n// node_modules/@trpc/client/dist/links/httpBatchLink.mjs\nvar throwFatalError = () => {\n  throw new Error(\"Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new\");\n};\nfunction dataLoader(batchLoader) {\n  let pendingItems = null;\n  let dispatchTimer = null;\n  const destroyTimerAndPendingItems = () => {\n    clearTimeout(dispatchTimer);\n    dispatchTimer = null;\n    pendingItems = null;\n  };\n  function groupItems(items) {\n    const groupedItems = [\n      []\n    ];\n    let index = 0;\n    while (true) {\n      const item = items[index];\n      if (!item) {\n        break;\n      }\n      const lastGroup = groupedItems[groupedItems.length - 1];\n      if (item.aborted) {\n        item.reject(new Error(\"Aborted\"));\n        index++;\n        continue;\n      }\n      const isValid = batchLoader.validate(lastGroup.concat(item).map((it) => it.key));\n      if (isValid) {\n        lastGroup.push(item);\n        index++;\n        continue;\n      }\n      if (lastGroup.length === 0) {\n        item.reject(new Error(\"Input is too big for a single dispatch\"));\n        index++;\n        continue;\n      }\n      groupedItems.push([]);\n    }\n    return groupedItems;\n  }\n  function dispatch() {\n    const groupedItems = groupItems(pendingItems);\n    destroyTimerAndPendingItems();\n    for (const items of groupedItems) {\n      if (!items.length) {\n        continue;\n      }\n      const batch = {\n        items,\n        cancel: throwFatalError\n      };\n      for (const item of items) {\n        item.batch = batch;\n      }\n      const { promise, cancel } = batchLoader.fetch(batch.items.map((_item) => _item.key));\n      batch.cancel = cancel;\n      promise.then((result) => {\n        for (let i = 0; i < result.length; i++) {\n          const value = result[i];\n          const item = batch.items[i];\n          item.resolve(value);\n          item.batch = null;\n        }\n      }).catch((cause) => {\n        for (const item of batch.items) {\n          item.reject(cause);\n          item.batch = null;\n        }\n      });\n    }\n  }\n  function load(key) {\n    const item = {\n      aborted: false,\n      key,\n      batch: null,\n      resolve: throwFatalError,\n      reject: throwFatalError\n    };\n    const promise = new Promise((resolve, reject) => {\n      item.reject = reject;\n      item.resolve = resolve;\n      if (!pendingItems) {\n        pendingItems = [];\n      }\n      pendingItems.push(item);\n    });\n    if (!dispatchTimer) {\n      dispatchTimer = setTimeout(dispatch);\n    }\n    const cancel = () => {\n      var _a;\n      item.aborted = true;\n      if ((_a = item.batch) == null ? void 0 : _a.items.every((item2) => item2.aborted)) {\n        item.batch.cancel();\n        item.batch = null;\n      }\n    };\n    return {\n      promise,\n      cancel\n    };\n  }\n  return {\n    load\n  };\n}\nfunction httpBatchLink(opts) {\n  const resolvedOpts = resolveHTTPLinkOptions(opts);\n  return (runtime) => {\n    const maxURLLength = opts.maxURLLength || Infinity;\n    const batchLoader = (type) => {\n      const validate = (batchOps) => {\n        if (maxURLLength === Infinity) {\n          return true;\n        }\n        const path = batchOps.map((op) => op.path).join(\",\");\n        const inputs = batchOps.map((op) => op.input);\n        const url = getUrl({\n          ...resolvedOpts,\n          runtime,\n          type,\n          path,\n          inputs\n        });\n        return url.length <= maxURLLength;\n      };\n      const fetch = (batchOps) => {\n        const path = batchOps.map((op) => op.path).join(\",\");\n        const inputs = batchOps.map((op) => op.input);\n        const { promise, cancel } = httpRequest({\n          ...resolvedOpts,\n          runtime,\n          type,\n          path,\n          inputs\n        });\n        return {\n          promise: promise.then((res) => {\n            const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(() => res.json);\n            const result = resJSON.map((item) => ({\n              meta: res.meta,\n              json: item\n            }));\n            return result;\n          }),\n          cancel\n        };\n      };\n      return {\n        validate,\n        fetch\n      };\n    };\n    const query = dataLoader(batchLoader(\"query\"));\n    const mutation = dataLoader(batchLoader(\"mutation\"));\n    const subscription = dataLoader(batchLoader(\"subscription\"));\n    const loaders = {\n      query,\n      subscription,\n      mutation\n    };\n    return ({ op }) => {\n      return observable((observer) => {\n        const loader = loaders[op.type];\n        const { promise, cancel } = loader.load(op);\n        promise.then((res) => {\n          const transformed = transformResult(res.json, runtime);\n          if (!transformed.ok) {\n            observer.error(TRPCClientError.from(transformed.error, {\n              meta: res.meta\n            }));\n            return;\n          }\n          observer.next({\n            context: res.meta,\n            result: transformed.result\n          });\n          observer.complete();\n        }).catch((err) => observer.error(TRPCClientError.from(err)));\n        return () => {\n          cancel();\n        };\n      });\n    };\n  };\n}\n\n// node_modules/@trpc/client/dist/links/httpLink.mjs\nfunction httpLink(opts) {\n  const resolvedOpts = resolveHTTPLinkOptions(opts);\n  return (runtime) => ({ op }) => observable((observer) => {\n    const { path, input, type } = op;\n    const { promise, cancel } = httpRequest({\n      ...resolvedOpts,\n      runtime,\n      type,\n      path,\n      input\n    });\n    promise.then((res) => {\n      const transformed = transformResult(res.json, runtime);\n      if (!transformed.ok) {\n        observer.error(TRPCClientError.from(transformed.error, {\n          meta: res.meta\n        }));\n        return;\n      }\n      observer.next({\n        context: res.meta,\n        result: transformed.result\n      });\n      observer.complete();\n    }).catch((cause) => observer.error(TRPCClientError.from(cause)));\n    return () => {\n      cancel();\n    };\n  });\n}\n\n// node_modules/@trpc/client/dist/links/loggerLink.mjs\nvar palette = {\n  query: [\n    \"72e3ff\",\n    \"3fb0d8\"\n  ],\n  mutation: [\n    \"c5a3fc\",\n    \"904dfc\"\n  ],\n  subscription: [\n    \"ff49e1\",\n    \"d83fbe\"\n  ]\n};\nvar defaultLogger = (c = console) => (props) => {\n  const { direction, input, type, path, context, id } = props;\n  const [light, dark] = palette[type];\n  const css = `\n    background-color: #${direction === \"up\" ? light : dark}; \n    color: ${direction === \"up\" ? \"black\" : \"white\"};\n    padding: 2px;\n  `;\n  const parts = [\n    \"%c\",\n    direction === \"up\" ? \">>\" : \"<<\",\n    type,\n    `#${id}`,\n    `%c${path}%c`,\n    \"%O\"\n  ];\n  const args = [\n    css,\n    `${css}; font-weight: bold;`,\n    `${css}; font-weight: normal;`\n  ];\n  if (props.direction === \"up\") {\n    args.push({\n      input,\n      context\n    });\n  } else {\n    args.push({\n      input,\n      result: props.result,\n      elapsedMs: props.elapsedMs,\n      context\n    });\n  }\n  const fn = props.direction === \"down\" && props.result && (props.result instanceof Error || \"error\" in props.result.result) ? \"error\" : \"log\";\n  c[fn].apply(null, [\n    parts.join(\" \")\n  ].concat(args));\n};\nfunction loggerLink(opts = {}) {\n  const { enabled = () => true } = opts;\n  const { logger = defaultLogger(opts.console) } = opts;\n  return () => {\n    return ({ op, next }) => {\n      return observable((observer) => {\n        enabled({\n          ...op,\n          direction: \"up\"\n        }) && logger({\n          ...op,\n          direction: \"up\"\n        });\n        const requestStartTime = Date.now();\n        function logResult(result) {\n          const elapsedMs = Date.now() - requestStartTime;\n          enabled({\n            ...op,\n            direction: \"down\",\n            result\n          }) && logger({\n            ...op,\n            direction: \"down\",\n            elapsedMs,\n            result\n          });\n        }\n        return next(op).pipe(tap({\n          next(result) {\n            logResult(result);\n          },\n          error(result) {\n            logResult(result);\n          }\n        })).subscribe(observer);\n      });\n    };\n  };\n}\n\n// node_modules/@trpc/client/dist/links/wsLink.mjs\nvar retryDelay = (attemptIndex) => attemptIndex === 0 ? 0 : Math.min(1e3 * 2 ** attemptIndex, 3e4);\nfunction createWSClient(opts) {\n  const { url, WebSocket: WebSocketImpl = WebSocket, retryDelayMs: retryDelayFn = retryDelay, onOpen, onClose } = opts;\n  if (!WebSocketImpl) {\n    throw new Error(\"No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill\");\n  }\n  let outgoing = [];\n  const pendingRequests = /* @__PURE__ */ Object.create(null);\n  let connectAttempt = 0;\n  let dispatchTimer = null;\n  let connectTimer = null;\n  let activeConnection = createWS();\n  let state = \"connecting\";\n  function dispatch() {\n    if (state !== \"open\" || dispatchTimer) {\n      return;\n    }\n    dispatchTimer = setTimeout(() => {\n      dispatchTimer = null;\n      if (outgoing.length === 1) {\n        activeConnection.send(JSON.stringify(outgoing.pop()));\n      } else {\n        activeConnection.send(JSON.stringify(outgoing));\n      }\n      outgoing = [];\n    });\n  }\n  function tryReconnect() {\n    if (connectTimer || state === \"closed\") {\n      return;\n    }\n    const timeout = retryDelayFn(connectAttempt++);\n    reconnectInMs(timeout);\n  }\n  function reconnect() {\n    state = \"connecting\";\n    const oldConnection = activeConnection;\n    activeConnection = createWS();\n    closeIfNoPending(oldConnection);\n  }\n  function reconnectInMs(ms) {\n    if (connectTimer) {\n      return;\n    }\n    state = \"connecting\";\n    connectTimer = setTimeout(reconnect, ms);\n  }\n  function closeIfNoPending(conn) {\n    const hasPendingRequests = Object.values(pendingRequests).some((p) => p.ws === conn);\n    if (!hasPendingRequests) {\n      conn.close();\n    }\n  }\n  function resumeSubscriptionOnReconnect(req) {\n    if (outgoing.some((r) => r.id === req.op.id)) {\n      return;\n    }\n    request(req.op, req.callbacks);\n  }\n  function createWS() {\n    const urlString = typeof url === \"function\" ? url() : url;\n    const conn = new WebSocketImpl(urlString);\n    clearTimeout(connectTimer);\n    connectTimer = null;\n    conn.addEventListener(\"open\", () => {\n      if (conn !== activeConnection) {\n        return;\n      }\n      connectAttempt = 0;\n      state = \"open\";\n      onOpen == null ? void 0 : onOpen();\n      dispatch();\n    });\n    conn.addEventListener(\"error\", () => {\n      if (conn === activeConnection) {\n        tryReconnect();\n      }\n    });\n    const handleIncomingRequest = (req) => {\n      if (req.method === \"reconnect\" && conn === activeConnection) {\n        if (state === \"open\") {\n          onClose == null ? void 0 : onClose();\n        }\n        reconnect();\n        for (const pendingReq of Object.values(pendingRequests)) {\n          if (pendingReq.type === \"subscription\") {\n            resumeSubscriptionOnReconnect(pendingReq);\n          }\n        }\n      }\n    };\n    const handleIncomingResponse = (data) => {\n      var _a, _b;\n      const req = data.id !== null && pendingRequests[data.id];\n      if (!req) {\n        return;\n      }\n      (_b = (_a = req.callbacks).next) == null ? void 0 : _b.call(_a, data);\n      if (req.ws !== activeConnection && conn === activeConnection) {\n        const oldWs = req.ws;\n        req.ws = activeConnection;\n        closeIfNoPending(oldWs);\n      }\n      if (\"result\" in data && data.result.type === \"stopped\" && conn === activeConnection) {\n        req.callbacks.complete();\n      }\n    };\n    conn.addEventListener(\"message\", ({ data }) => {\n      const msg = JSON.parse(data);\n      if (\"method\" in msg) {\n        handleIncomingRequest(msg);\n      } else {\n        handleIncomingResponse(msg);\n      }\n      if (conn !== activeConnection || state === \"closed\") {\n        closeIfNoPending(conn);\n      }\n    });\n    conn.addEventListener(\"close\", ({ code }) => {\n      var _a, _b, _c, _d;\n      if (state === \"open\") {\n        onClose == null ? void 0 : onClose({\n          code\n        });\n      }\n      if (activeConnection === conn) {\n        tryReconnect();\n      }\n      for (const [key, req] of Object.entries(pendingRequests)) {\n        if (req.ws !== conn) {\n          continue;\n        }\n        if (state === \"closed\") {\n          delete pendingRequests[key];\n          (_b = (_a = req.callbacks).complete) == null ? void 0 : _b.call(_a);\n          continue;\n        }\n        if (req.type === \"subscription\") {\n          resumeSubscriptionOnReconnect(req);\n        } else {\n          delete pendingRequests[key];\n          (_d = (_c = req.callbacks).error) == null ? void 0 : _d.call(_c, TRPCClientError.from(new TRPCWebSocketClosedError(\"WebSocket closed prematurely\")));\n        }\n      }\n    });\n    return conn;\n  }\n  function request(op, callbacks) {\n    const { type, input, path, id } = op;\n    const envelope = {\n      id,\n      method: type,\n      params: {\n        input,\n        path\n      }\n    };\n    pendingRequests[id] = {\n      ws: activeConnection,\n      type,\n      callbacks,\n      op\n    };\n    outgoing.push(envelope);\n    dispatch();\n    return () => {\n      var _a, _b;\n      const callbacks2 = (_a = pendingRequests[id]) == null ? void 0 : _a.callbacks;\n      delete pendingRequests[id];\n      outgoing = outgoing.filter((msg) => msg.id !== id);\n      (_b = callbacks2 == null ? void 0 : callbacks2.complete) == null ? void 0 : _b.call(callbacks2);\n      if (activeConnection.readyState === WebSocketImpl.OPEN && op.type === \"subscription\") {\n        outgoing.push({\n          id,\n          method: \"subscription.stop\"\n        });\n        dispatch();\n      }\n    };\n  }\n  return {\n    close: () => {\n      state = \"closed\";\n      onClose == null ? void 0 : onClose();\n      closeIfNoPending(activeConnection);\n      clearTimeout(connectTimer);\n      connectTimer = null;\n    },\n    request,\n    getConnection() {\n      return activeConnection;\n    }\n  };\n}\nvar TRPCWebSocketClosedError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"TRPCWebSocketClosedError\";\n    Object.setPrototypeOf(this, TRPCWebSocketClosedError.prototype);\n  }\n};\nvar TRPCSubscriptionEndedError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"TRPCSubscriptionEndedError\";\n    Object.setPrototypeOf(this, TRPCSubscriptionEndedError.prototype);\n  }\n};\nfunction wsLink(opts) {\n  return (runtime) => {\n    const { client } = opts;\n    return ({ op }) => {\n      return observable((observer) => {\n        const { type, path, id, context } = op;\n        const input = runtime.transformer.serialize(op.input);\n        let isDone = false;\n        const unsub = client.request({\n          type,\n          path,\n          input,\n          id,\n          context\n        }, {\n          error(err) {\n            isDone = true;\n            observer.error(err);\n            unsub();\n          },\n          complete() {\n            if (!isDone) {\n              isDone = true;\n              observer.error(TRPCClientError.from(new TRPCSubscriptionEndedError(\"Operation ended prematurely\")));\n            } else {\n              observer.complete();\n            }\n          },\n          next(message) {\n            const transformed = transformResult(message, runtime);\n            if (!transformed.ok) {\n              observer.error(TRPCClientError.from(transformed.error));\n              return;\n            }\n            observer.next({\n              result: transformed.result\n            });\n            if (op.type !== \"subscription\") {\n              isDone = true;\n              unsub();\n              observer.complete();\n            }\n          }\n        });\n        return () => {\n          isDone = true;\n          unsub();\n        };\n      });\n    };\n  };\n}\n\n// node_modules/@trpc/client/dist/index.mjs\nvar TRPCUntypedClient = class {\n  $request({ type, input, path, context = {} }) {\n    const chain$ = createChain({\n      links: this.links,\n      op: {\n        id: ++this.requestId,\n        type,\n        path,\n        input,\n        context\n      }\n    });\n    return chain$.pipe(share());\n  }\n  requestAsPromise(opts) {\n    const req$ = this.$request(opts);\n    const { promise, abort } = observableToPromise(req$);\n    const abortablePromise = new Promise((resolve, reject) => {\n      var _a;\n      (_a = opts.signal) == null ? void 0 : _a.addEventListener(\"abort\", abort);\n      promise.then((envelope) => {\n        resolve(envelope.result.data);\n      }).catch((err) => {\n        reject(TRPCClientError.from(err));\n      });\n    });\n    return abortablePromise;\n  }\n  query(path, input, opts) {\n    return this.requestAsPromise({\n      type: \"query\",\n      path,\n      input,\n      context: opts == null ? void 0 : opts.context,\n      signal: opts == null ? void 0 : opts.signal\n    });\n  }\n  mutation(path, input, opts) {\n    return this.requestAsPromise({\n      type: \"mutation\",\n      path,\n      input,\n      context: opts == null ? void 0 : opts.context,\n      signal: opts == null ? void 0 : opts.signal\n    });\n  }\n  subscription(path, input, opts) {\n    const observable$ = this.$request({\n      type: \"subscription\",\n      path,\n      input,\n      context: opts == null ? void 0 : opts.context\n    });\n    return observable$.subscribe({\n      next(envelope) {\n        var _a, _b, _c;\n        if (envelope.result.type === \"started\") {\n          (_a = opts.onStarted) == null ? void 0 : _a.call(opts);\n        } else if (envelope.result.type === \"stopped\") {\n          (_b = opts.onStopped) == null ? void 0 : _b.call(opts);\n        } else {\n          (_c = opts.onData) == null ? void 0 : _c.call(opts, envelope.result.data);\n        }\n      },\n      error(err) {\n        var _a;\n        (_a = opts.onError) == null ? void 0 : _a.call(opts, err);\n      },\n      complete() {\n        var _a;\n        (_a = opts.onComplete) == null ? void 0 : _a.call(opts);\n      }\n    });\n  }\n  constructor(opts) {\n    this.requestId = 0;\n    function getTransformer() {\n      const transformer = opts.transformer;\n      if (!transformer)\n        return {\n          serialize: (data) => data,\n          deserialize: (data) => data\n        };\n      if (\"input\" in transformer)\n        return {\n          serialize: transformer.input.serialize,\n          deserialize: transformer.output.deserialize\n        };\n      return transformer;\n    }\n    this.runtime = {\n      transformer: getTransformer()\n    };\n    this.links = opts.links.map((link) => link(this.runtime));\n  }\n};\nfunction createTRPCUntypedClient(opts) {\n  const client = new TRPCUntypedClient(opts);\n  return client;\n}\nfunction createTRPCClient(opts) {\n  const client = new TRPCUntypedClient(opts);\n  return client;\n}\nvar clientCallTypeMap = {\n  query: \"query\",\n  mutate: \"mutation\",\n  subscribe: \"subscription\"\n};\nfunction createTRPCClientProxy(client) {\n  return createFlatProxy((key) => {\n    if (client.hasOwnProperty(key)) {\n      return client[key];\n    }\n    return createRecursiveProxy(({ path, args }) => {\n      const pathCopy = [\n        key,\n        ...path\n      ];\n      const clientCallType = pathCopy.pop();\n      const procedureType = clientCallTypeMap[clientCallType];\n      const fullPath = pathCopy.join(\".\");\n      return client[procedureType](fullPath, ...args);\n    });\n  });\n}\nfunction createTRPCProxyClient(opts) {\n  const client = new TRPCUntypedClient(opts);\n  const proxy = createTRPCClientProxy(client);\n  return proxy;\n}\nexport {\n  TRPCClientError,\n  createTRPCClient,\n  createTRPCClientProxy,\n  createTRPCProxyClient,\n  createTRPCUntypedClient,\n  createWSClient,\n  getFetch,\n  httpBatchLink,\n  httpLink,\n  loggerLink,\n  splitLink,\n  wsLink\n};\n//# sourceMappingURL=@trpc_client.js.map\n","start":1676889525529,"end":1676889525530,"order":"normal"}]}
