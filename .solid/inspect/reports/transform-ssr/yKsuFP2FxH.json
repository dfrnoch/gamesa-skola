{"resolvedId":"C:/Users/tobis/gamesa-skola/node_modules/solid-start-trpc/dist/index.js","transforms":[{"name":"__load__","result":"function getMessageFromUnknownError(err, fallback) {\n    if (typeof err === 'string') {\n        return err;\n    }\n    if (err instanceof Error && typeof err.message === 'string') {\n        return err.message;\n    }\n    return fallback;\n}\nfunction getErrorFromUnknown(cause) {\n    if (cause instanceof Error) {\n        return cause;\n    }\n    const message = getMessageFromUnknownError(cause, 'Unknown error');\n    return new Error(message);\n}\nfunction getTRPCErrorFromUnknown(cause) {\n    const error = getErrorFromUnknown(cause);\n    // this should ideally be an `instanceof TRPCError` but for some reason that isn't working\n    // ref https://github.com/trpc/trpc/issues/331\n    if (error.name === 'TRPCError') {\n        return cause;\n    }\n    const trpcError = new TRPCError({\n        code: 'INTERNAL_SERVER_ERROR',\n        cause: error,\n        message: error.message\n    });\n    // Inherit stack from error\n    trpcError.stack = error.stack;\n    return trpcError;\n}\nfunction getCauseFromUnknown(cause) {\n    if (cause instanceof Error) {\n        return cause;\n    }\n    return undefined;\n}\n\nclass TRPCError extends Error {\n    constructor(opts){\n        const code = opts.code;\n        const message = opts.message ?? getMessageFromUnknownError(opts.cause, code);\n        const cause = opts !== undefined ? getErrorFromUnknown(opts.cause) : undefined;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore https://github.com/tc39/proposal-error-cause\n        super(message, {\n            cause\n        });\n        this.code = code;\n        this.cause = cause;\n        this.name = 'TRPCError';\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n\nfunction invert(obj) {\n    const newObj = Object.create(null);\n    for(const key in obj){\n        const v = obj[key];\n        newObj[v] = key;\n    }\n    return newObj;\n}\n\n// reference: https://www.jsonrpc.org/specification\n/**\n * JSON-RPC 2.0 Error codes\n *\n * `-32000` to `-32099` are reserved for implementation-defined server-errors.\n * For tRPC we're copying the last digits of HTTP 4XX errors.\n */ const TRPC_ERROR_CODES_BY_KEY = {\n    /**\n   * Invalid JSON was received by the server.\n   * An error occurred on the server while parsing the JSON text.\n   */ PARSE_ERROR: -32700,\n    /**\n   * The JSON sent is not a valid Request object.\n   */ BAD_REQUEST: -32600,\n    /**\n   * Internal JSON-RPC error.\n   */ INTERNAL_SERVER_ERROR: -32603,\n    // Implementation specific errors\n    UNAUTHORIZED: -32001,\n    FORBIDDEN: -32003,\n    NOT_FOUND: -32004,\n    METHOD_NOT_SUPPORTED: -32005,\n    TIMEOUT: -32008,\n    CONFLICT: -32009,\n    PRECONDITION_FAILED: -32012,\n    PAYLOAD_TOO_LARGE: -32013,\n    TOO_MANY_REQUESTS: -32029,\n    CLIENT_CLOSED_REQUEST: -32099\n};\ninvert(TRPC_ERROR_CODES_BY_KEY);\n\nconst TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);\nconst JSONRPC2_TO_HTTP_CODE = {\n    PARSE_ERROR: 400,\n    BAD_REQUEST: 400,\n    NOT_FOUND: 404,\n    INTERNAL_SERVER_ERROR: 500,\n    UNAUTHORIZED: 401,\n    FORBIDDEN: 403,\n    TIMEOUT: 408,\n    CONFLICT: 409,\n    CLIENT_CLOSED_REQUEST: 499,\n    PRECONDITION_FAILED: 412,\n    PAYLOAD_TOO_LARGE: 413,\n    METHOD_NOT_SUPPORTED: 405,\n    TOO_MANY_REQUESTS: 429\n};\nfunction getStatusCodeFromKey(code) {\n    return JSONRPC2_TO_HTTP_CODE[code] ?? 500;\n}\nfunction getHTTPStatusCode(json) {\n    const arr = Array.isArray(json) ? json : [\n        json\n    ];\n    const httpStatuses = new Set(arr.map((res)=>{\n        if ('error' in res) {\n            const data = res.error.data;\n            if (typeof data.httpStatus === 'number') {\n                return data.httpStatus;\n            }\n            const code = TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n            return getStatusCodeFromKey(code);\n        }\n        return 200;\n    }));\n    if (httpStatuses.size !== 1) {\n        return 207;\n    }\n    const httpStatus = httpStatuses.values().next().value;\n    return httpStatus;\n}\n/**\n * @internal\n */ function callProcedure(opts) {\n    const { type , path  } = opts;\n    if (!(path in opts.procedures) || !opts.procedures[path]?._def[type]) {\n        throw new TRPCError({\n            code: 'NOT_FOUND',\n            message: `No \"${type}\"-procedure on path \"${path}\"`\n        });\n    }\n    const procedure = opts.procedures[path];\n    return procedure(opts);\n}\n\n/**\n * The default check to see if we're in a server\n */ typeof window === 'undefined' || 'Deno' in window || globalThis.process?.env?.NODE_ENV === 'test' || !!globalThis.process?.env?.JEST_WORKER_ID;\n\nfunction getPath(args) {\n  const p = args.params.trpc;\n  if (typeof p === \"string\") {\n    return p;\n  }\n  if (Array.isArray(p)) {\n    return p.join(\"/\");\n  }\n  return null;\n}\nfunction notFoundError(opts) {\n  const error = opts.router.getErrorShape({\n    error: new TRPCError({\n      message: 'Query \"trpc\" not found - is the file named `[trpc]`.ts or `[...trpc].ts`?',\n      code: \"INTERNAL_SERVER_ERROR\"\n    }),\n    type: \"unknown\",\n    ctx: undefined,\n    path: undefined,\n    input: undefined\n  });\n  const json = {\n    id: -1,\n    error\n  };\n  return new Response(JSON.stringify(json), {\n    status: 500\n  });\n}\n\nfunction transformTRPCResponseItem(router, item) {\n    if ('error' in item) {\n        return {\n            ...item,\n            error: router._def._config.transformer.output.serialize(item.error)\n        };\n    }\n    if ('data' in item.result) {\n        return {\n            ...item,\n            result: {\n                ...item.result,\n                data: router._def._config.transformer.output.serialize(item.result.data)\n            }\n        };\n    }\n    return item;\n}\n/**\n * Takes a unserialized `TRPCResponse` and serializes it with the router's transformers\n **/ function transformTRPCResponse(router, itemOrItems) {\n    return Array.isArray(itemOrItems) ? itemOrItems.map((item)=>transformTRPCResponseItem(router, item)) : transformTRPCResponseItem(router, itemOrItems);\n}\n\nconst HTTP_METHOD_PROCEDURE_TYPE_MAP = {\n    GET: 'query',\n    POST: 'mutation'\n};\nfunction getRawProcedureInputOrThrow(req) {\n    try {\n        if (req.method === 'GET') {\n            if (!req.query.has('input')) {\n                return undefined;\n            }\n            const raw = req.query.get('input');\n            return JSON.parse(raw);\n        }\n        if (typeof req.body === 'string') {\n            // A mutation with no inputs will have req.body === ''\n            return req.body.length === 0 ? undefined : JSON.parse(req.body);\n        }\n        return req.body;\n    } catch (err) {\n        throw new TRPCError({\n            code: 'PARSE_ERROR',\n            cause: getCauseFromUnknown(err)\n        });\n    }\n}\nasync function resolveHTTPResponse(opts) {\n    const { createContext , onError , router , req  } = opts;\n    const batchingEnabled = opts.batching?.enabled ?? true;\n    if (req.method === 'HEAD') {\n        // can be used for lambda warmup\n        return {\n            status: 204\n        };\n    }\n    const type = HTTP_METHOD_PROCEDURE_TYPE_MAP[req.method] ?? 'unknown';\n    let ctx = undefined;\n    let paths = undefined;\n    const isBatchCall = !!req.query.get('batch');\n    function endResponse(untransformedJSON, errors) {\n        let status = getHTTPStatusCode(untransformedJSON);\n        const headers = {\n            'Content-Type': 'application/json'\n        };\n        const meta = opts.responseMeta?.({\n            ctx,\n            paths,\n            type,\n            data: Array.isArray(untransformedJSON) ? untransformedJSON : [\n                untransformedJSON\n            ],\n            errors\n        }) ?? {};\n        for (const [key, value] of Object.entries(meta.headers ?? {})){\n            headers[key] = value;\n        }\n        if (meta.status) {\n            status = meta.status;\n        }\n        const transformedJSON = transformTRPCResponse(router, untransformedJSON);\n        const body = JSON.stringify(transformedJSON);\n        return {\n            body,\n            status,\n            headers\n        };\n    }\n    try {\n        if (opts.error) {\n            throw opts.error;\n        }\n        if (isBatchCall && !batchingEnabled) {\n            throw new Error(`Batching is not enabled on the server`);\n        }\n        /* istanbul ignore if  */ if (type === 'subscription') {\n            throw new TRPCError({\n                message: 'Subscriptions should use wsLink',\n                code: 'METHOD_NOT_SUPPORTED'\n            });\n        }\n        if (type === 'unknown') {\n            throw new TRPCError({\n                message: `Unexpected request method ${req.method}`,\n                code: 'METHOD_NOT_SUPPORTED'\n            });\n        }\n        const rawInput = getRawProcedureInputOrThrow(req);\n        paths = isBatchCall ? opts.path.split(',') : [\n            opts.path\n        ];\n        ctx = await createContext();\n        const deserializeInputValue = (rawValue)=>{\n            return typeof rawValue !== 'undefined' ? router._def._config.transformer.input.deserialize(rawValue) : rawValue;\n        };\n        const getInputs = ()=>{\n            if (!isBatchCall) {\n                return {\n                    0: deserializeInputValue(rawInput)\n                };\n            }\n            /* istanbul ignore if  */ if (rawInput == null || typeof rawInput !== 'object' || Array.isArray(rawInput)) {\n                throw new TRPCError({\n                    code: 'BAD_REQUEST',\n                    message: '\"input\" needs to be an object when doing a batch call'\n                });\n            }\n            const input = {};\n            for(const key in rawInput){\n                const k = key;\n                const rawValue = rawInput[k];\n                const value = deserializeInputValue(rawValue);\n                input[k] = value;\n            }\n            return input;\n        };\n        const inputs = getInputs();\n        const rawResults = await Promise.all(paths.map(async (path, index)=>{\n            const input = inputs[index];\n            try {\n                const output = await callProcedure({\n                    procedures: router._def.procedures,\n                    path,\n                    rawInput: input,\n                    ctx,\n                    type\n                });\n                return {\n                    input,\n                    path,\n                    data: output\n                };\n            } catch (cause) {\n                const error = getTRPCErrorFromUnknown(cause);\n                onError?.({\n                    error,\n                    path,\n                    input,\n                    ctx,\n                    type: type,\n                    req\n                });\n                return {\n                    input,\n                    path,\n                    error\n                };\n            }\n        }));\n        const errors = rawResults.flatMap((obj)=>obj.error ? [\n                obj.error\n            ] : []);\n        const resultEnvelopes = rawResults.map((obj)=>{\n            const { path , input  } = obj;\n            if (obj.error) {\n                return {\n                    error: router.getErrorShape({\n                        error: obj.error,\n                        type,\n                        path,\n                        input,\n                        ctx\n                    })\n                };\n            } else {\n                return {\n                    result: {\n                        data: obj.data\n                    }\n                };\n            }\n        });\n        const result = isBatchCall ? resultEnvelopes : resultEnvelopes[0];\n        return endResponse(result, errors);\n    } catch (cause) {\n        // we get here if\n        // - batching is called when it's not enabled\n        // - `createContext()` throws\n        // - post body is too large\n        // - input deserialization fails\n        const error = getTRPCErrorFromUnknown(cause);\n        onError?.({\n            error,\n            path: undefined,\n            input: undefined,\n            ctx,\n            type: type,\n            req\n        });\n        return endResponse({\n            error: router.getErrorShape({\n                error,\n                type,\n                path: undefined,\n                input: undefined,\n                ctx\n            })\n        }, [\n            error\n        ]);\n    }\n}\n\nfunction createSolidAPIHandler(opts) {\n  return async args => {\n    const path = getPath(args);\n    if (path === null) {\n      return notFoundError(opts);\n    }\n    const res = {\n      headers: {}\n    };\n    const url = new URL(args.request.url);\n    const req = {\n      query: url.searchParams,\n      method: args.request.method,\n      headers: Object.fromEntries(args.request.headers),\n      body: await args.request.text()\n    };\n    const result = await resolveHTTPResponse({\n      router: opts.router,\n      responseMeta: opts.responseMeta,\n      req,\n      path,\n      createContext: async () => await opts.createContext?.({\n        req: args.request,\n        res\n      })\n    });\n    const mRes = new Response(result.body, {\n      status: result.status\n    });\n    for (const [key, value] of Object.entries(result.headers ? {\n      ...res.headers,\n      ...result.headers\n    } : res.headers)) {\n      if (typeof value === \"undefined\") {\n        continue;\n      }\n      if (typeof value === \"string\") {\n        mRes.headers.set(key, value);\n        continue;\n      }\n      for (const v of value) {\n        mRes.headers.append(key, v);\n      }\n    }\n    return mRes;\n  };\n}\n\nexport { createSolidAPIHandler };\n","start":1676889522758,"end":1676889522758},{"name":"vite:define","result":"function getMessageFromUnknownError(err, fallback) {\n    if (typeof err === 'string') {\n        return err;\n    }\n    if (err instanceof Error && typeof err.message === 'string') {\n        return err.message;\n    }\n    return fallback;\n}\nfunction getErrorFromUnknown(cause) {\n    if (cause instanceof Error) {\n        return cause;\n    }\n    const message = getMessageFromUnknownError(cause, 'Unknown error');\n    return new Error(message);\n}\nfunction getTRPCErrorFromUnknown(cause) {\n    const error = getErrorFromUnknown(cause);\n    // this should ideally be an `instanceof TRPCError` but for some reason that isn't working\n    // ref https://github.com/trpc/trpc/issues/331\n    if (error.name === 'TRPCError') {\n        return cause;\n    }\n    const trpcError = new TRPCError({\n        code: 'INTERNAL_SERVER_ERROR',\n        cause: error,\n        message: error.message\n    });\n    // Inherit stack from error\n    trpcError.stack = error.stack;\n    return trpcError;\n}\nfunction getCauseFromUnknown(cause) {\n    if (cause instanceof Error) {\n        return cause;\n    }\n    return undefined;\n}\n\nclass TRPCError extends Error {\n    constructor(opts){\n        const code = opts.code;\n        const message = opts.message ?? getMessageFromUnknownError(opts.cause, code);\n        const cause = opts !== undefined ? getErrorFromUnknown(opts.cause) : undefined;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore https://github.com/tc39/proposal-error-cause\n        super(message, {\n            cause\n        });\n        this.code = code;\n        this.cause = cause;\n        this.name = 'TRPCError';\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n\nfunction invert(obj) {\n    const newObj = Object.create(null);\n    for(const key in obj){\n        const v = obj[key];\n        newObj[v] = key;\n    }\n    return newObj;\n}\n\n// reference: https://www.jsonrpc.org/specification\n/**\n * JSON-RPC 2.0 Error codes\n *\n * `-32000` to `-32099` are reserved for implementation-defined server-errors.\n * For tRPC we're copying the last digits of HTTP 4XX errors.\n */ const TRPC_ERROR_CODES_BY_KEY = {\n    /**\n   * Invalid JSON was received by the server.\n   * An error occurred on the server while parsing the JSON text.\n   */ PARSE_ERROR: -32700,\n    /**\n   * The JSON sent is not a valid Request object.\n   */ BAD_REQUEST: -32600,\n    /**\n   * Internal JSON-RPC error.\n   */ INTERNAL_SERVER_ERROR: -32603,\n    // Implementation specific errors\n    UNAUTHORIZED: -32001,\n    FORBIDDEN: -32003,\n    NOT_FOUND: -32004,\n    METHOD_NOT_SUPPORTED: -32005,\n    TIMEOUT: -32008,\n    CONFLICT: -32009,\n    PRECONDITION_FAILED: -32012,\n    PAYLOAD_TOO_LARGE: -32013,\n    TOO_MANY_REQUESTS: -32029,\n    CLIENT_CLOSED_REQUEST: -32099\n};\ninvert(TRPC_ERROR_CODES_BY_KEY);\n\nconst TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);\nconst JSONRPC2_TO_HTTP_CODE = {\n    PARSE_ERROR: 400,\n    BAD_REQUEST: 400,\n    NOT_FOUND: 404,\n    INTERNAL_SERVER_ERROR: 500,\n    UNAUTHORIZED: 401,\n    FORBIDDEN: 403,\n    TIMEOUT: 408,\n    CONFLICT: 409,\n    CLIENT_CLOSED_REQUEST: 499,\n    PRECONDITION_FAILED: 412,\n    PAYLOAD_TOO_LARGE: 413,\n    METHOD_NOT_SUPPORTED: 405,\n    TOO_MANY_REQUESTS: 429\n};\nfunction getStatusCodeFromKey(code) {\n    return JSONRPC2_TO_HTTP_CODE[code] ?? 500;\n}\nfunction getHTTPStatusCode(json) {\n    const arr = Array.isArray(json) ? json : [\n        json\n    ];\n    const httpStatuses = new Set(arr.map((res)=>{\n        if ('error' in res) {\n            const data = res.error.data;\n            if (typeof data.httpStatus === 'number') {\n                return data.httpStatus;\n            }\n            const code = TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n            return getStatusCodeFromKey(code);\n        }\n        return 200;\n    }));\n    if (httpStatuses.size !== 1) {\n        return 207;\n    }\n    const httpStatus = httpStatuses.values().next().value;\n    return httpStatus;\n}\n/**\n * @internal\n */ function callProcedure(opts) {\n    const { type , path  } = opts;\n    if (!(path in opts.procedures) || !opts.procedures[path]?._def[type]) {\n        throw new TRPCError({\n            code: 'NOT_FOUND',\n            message: `No \"${type}\"-procedure on path \"${path}\"`\n        });\n    }\n    const procedure = opts.procedures[path];\n    return procedure(opts);\n}\n\n/**\n * The default check to see if we're in a server\n */ typeof window === 'undefined' || 'Deno' in window || globalThis.process?.env?.NODE_ENV === 'test' || !!globalThis.process?.env?.JEST_WORKER_ID;\n\nfunction getPath(args) {\n  const p = args.params.trpc;\n  if (typeof p === \"string\") {\n    return p;\n  }\n  if (Array.isArray(p)) {\n    return p.join(\"/\");\n  }\n  return null;\n}\nfunction notFoundError(opts) {\n  const error = opts.router.getErrorShape({\n    error: new TRPCError({\n      message: 'Query \"trpc\" not found - is the file named `[trpc]`.ts or `[...trpc].ts`?',\n      code: \"INTERNAL_SERVER_ERROR\"\n    }),\n    type: \"unknown\",\n    ctx: undefined,\n    path: undefined,\n    input: undefined\n  });\n  const json = {\n    id: -1,\n    error\n  };\n  return new Response(JSON.stringify(json), {\n    status: 500\n  });\n}\n\nfunction transformTRPCResponseItem(router, item) {\n    if ('error' in item) {\n        return {\n            ...item,\n            error: router._def._config.transformer.output.serialize(item.error)\n        };\n    }\n    if ('data' in item.result) {\n        return {\n            ...item,\n            result: {\n                ...item.result,\n                data: router._def._config.transformer.output.serialize(item.result.data)\n            }\n        };\n    }\n    return item;\n}\n/**\n * Takes a unserialized `TRPCResponse` and serializes it with the router's transformers\n **/ function transformTRPCResponse(router, itemOrItems) {\n    return Array.isArray(itemOrItems) ? itemOrItems.map((item)=>transformTRPCResponseItem(router, item)) : transformTRPCResponseItem(router, itemOrItems);\n}\n\nconst HTTP_METHOD_PROCEDURE_TYPE_MAP = {\n    GET: 'query',\n    POST: 'mutation'\n};\nfunction getRawProcedureInputOrThrow(req) {\n    try {\n        if (req.method === 'GET') {\n            if (!req.query.has('input')) {\n                return undefined;\n            }\n            const raw = req.query.get('input');\n            return JSON.parse(raw);\n        }\n        if (typeof req.body === 'string') {\n            // A mutation with no inputs will have req.body === ''\n            return req.body.length === 0 ? undefined : JSON.parse(req.body);\n        }\n        return req.body;\n    } catch (err) {\n        throw new TRPCError({\n            code: 'PARSE_ERROR',\n            cause: getCauseFromUnknown(err)\n        });\n    }\n}\nasync function resolveHTTPResponse(opts) {\n    const { createContext , onError , router , req  } = opts;\n    const batchingEnabled = opts.batching?.enabled ?? true;\n    if (req.method === 'HEAD') {\n        // can be used for lambda warmup\n        return {\n            status: 204\n        };\n    }\n    const type = HTTP_METHOD_PROCEDURE_TYPE_MAP[req.method] ?? 'unknown';\n    let ctx = undefined;\n    let paths = undefined;\n    const isBatchCall = !!req.query.get('batch');\n    function endResponse(untransformedJSON, errors) {\n        let status = getHTTPStatusCode(untransformedJSON);\n        const headers = {\n            'Content-Type': 'application/json'\n        };\n        const meta = opts.responseMeta?.({\n            ctx,\n            paths,\n            type,\n            data: Array.isArray(untransformedJSON) ? untransformedJSON : [\n                untransformedJSON\n            ],\n            errors\n        }) ?? {};\n        for (const [key, value] of Object.entries(meta.headers ?? {})){\n            headers[key] = value;\n        }\n        if (meta.status) {\n            status = meta.status;\n        }\n        const transformedJSON = transformTRPCResponse(router, untransformedJSON);\n        const body = JSON.stringify(transformedJSON);\n        return {\n            body,\n            status,\n            headers\n        };\n    }\n    try {\n        if (opts.error) {\n            throw opts.error;\n        }\n        if (isBatchCall && !batchingEnabled) {\n            throw new Error(`Batching is not enabled on the server`);\n        }\n        /* istanbul ignore if  */ if (type === 'subscription') {\n            throw new TRPCError({\n                message: 'Subscriptions should use wsLink',\n                code: 'METHOD_NOT_SUPPORTED'\n            });\n        }\n        if (type === 'unknown') {\n            throw new TRPCError({\n                message: `Unexpected request method ${req.method}`,\n                code: 'METHOD_NOT_SUPPORTED'\n            });\n        }\n        const rawInput = getRawProcedureInputOrThrow(req);\n        paths = isBatchCall ? opts.path.split(',') : [\n            opts.path\n        ];\n        ctx = await createContext();\n        const deserializeInputValue = (rawValue)=>{\n            return typeof rawValue !== 'undefined' ? router._def._config.transformer.input.deserialize(rawValue) : rawValue;\n        };\n        const getInputs = ()=>{\n            if (!isBatchCall) {\n                return {\n                    0: deserializeInputValue(rawInput)\n                };\n            }\n            /* istanbul ignore if  */ if (rawInput == null || typeof rawInput !== 'object' || Array.isArray(rawInput)) {\n                throw new TRPCError({\n                    code: 'BAD_REQUEST',\n                    message: '\"input\" needs to be an object when doing a batch call'\n                });\n            }\n            const input = {};\n            for(const key in rawInput){\n                const k = key;\n                const rawValue = rawInput[k];\n                const value = deserializeInputValue(rawValue);\n                input[k] = value;\n            }\n            return input;\n        };\n        const inputs = getInputs();\n        const rawResults = await Promise.all(paths.map(async (path, index)=>{\n            const input = inputs[index];\n            try {\n                const output = await callProcedure({\n                    procedures: router._def.procedures,\n                    path,\n                    rawInput: input,\n                    ctx,\n                    type\n                });\n                return {\n                    input,\n                    path,\n                    data: output\n                };\n            } catch (cause) {\n                const error = getTRPCErrorFromUnknown(cause);\n                onError?.({\n                    error,\n                    path,\n                    input,\n                    ctx,\n                    type: type,\n                    req\n                });\n                return {\n                    input,\n                    path,\n                    error\n                };\n            }\n        }));\n        const errors = rawResults.flatMap((obj)=>obj.error ? [\n                obj.error\n            ] : []);\n        const resultEnvelopes = rawResults.map((obj)=>{\n            const { path , input  } = obj;\n            if (obj.error) {\n                return {\n                    error: router.getErrorShape({\n                        error: obj.error,\n                        type,\n                        path,\n                        input,\n                        ctx\n                    })\n                };\n            } else {\n                return {\n                    result: {\n                        data: obj.data\n                    }\n                };\n            }\n        });\n        const result = isBatchCall ? resultEnvelopes : resultEnvelopes[0];\n        return endResponse(result, errors);\n    } catch (cause) {\n        // we get here if\n        // - batching is called when it's not enabled\n        // - `createContext()` throws\n        // - post body is too large\n        // - input deserialization fails\n        const error = getTRPCErrorFromUnknown(cause);\n        onError?.({\n            error,\n            path: undefined,\n            input: undefined,\n            ctx,\n            type: type,\n            req\n        });\n        return endResponse({\n            error: router.getErrorShape({\n                error,\n                type,\n                path: undefined,\n                input: undefined,\n                ctx\n            })\n        }, [\n            error\n        ]);\n    }\n}\n\nfunction createSolidAPIHandler(opts) {\n  return async args => {\n    const path = getPath(args);\n    if (path === null) {\n      return notFoundError(opts);\n    }\n    const res = {\n      headers: {}\n    };\n    const url = new URL(args.request.url);\n    const req = {\n      query: url.searchParams,\n      method: args.request.method,\n      headers: Object.fromEntries(args.request.headers),\n      body: await args.request.text()\n    };\n    const result = await resolveHTTPResponse({\n      router: opts.router,\n      responseMeta: opts.responseMeta,\n      req,\n      path,\n      createContext: async () => await opts.createContext?.({\n        req: args.request,\n        res\n      })\n    });\n    const mRes = new Response(result.body, {\n      status: result.status\n    });\n    for (const [key, value] of Object.entries(result.headers ? {\n      ...res.headers,\n      ...result.headers\n    } : res.headers)) {\n      if (typeof value === \"undefined\") {\n        continue;\n      }\n      if (typeof value === \"string\") {\n        mRes.headers.set(key, value);\n        continue;\n      }\n      for (const v of value) {\n        mRes.headers.append(key, v);\n      }\n    }\n    return mRes;\n  };\n}\n\nexport { createSolidAPIHandler };\n","start":1676889522758,"end":1676889522758,"order":"normal"},{"name":"vite:import-analysis","result":"function getMessageFromUnknownError(err, fallback) {\n    if (typeof err === 'string') {\n        return err;\n    }\n    if (err instanceof Error && typeof err.message === 'string') {\n        return err.message;\n    }\n    return fallback;\n}\nfunction getErrorFromUnknown(cause) {\n    if (cause instanceof Error) {\n        return cause;\n    }\n    const message = getMessageFromUnknownError(cause, 'Unknown error');\n    return new Error(message);\n}\nfunction getTRPCErrorFromUnknown(cause) {\n    const error = getErrorFromUnknown(cause);\n    // this should ideally be an `instanceof TRPCError` but for some reason that isn't working\n    // ref https://github.com/trpc/trpc/issues/331\n    if (error.name === 'TRPCError') {\n        return cause;\n    }\n    const trpcError = new TRPCError({\n        code: 'INTERNAL_SERVER_ERROR',\n        cause: error,\n        message: error.message\n    });\n    // Inherit stack from error\n    trpcError.stack = error.stack;\n    return trpcError;\n}\nfunction getCauseFromUnknown(cause) {\n    if (cause instanceof Error) {\n        return cause;\n    }\n    return undefined;\n}\n\nclass TRPCError extends Error {\n    constructor(opts){\n        const code = opts.code;\n        const message = opts.message ?? getMessageFromUnknownError(opts.cause, code);\n        const cause = opts !== undefined ? getErrorFromUnknown(opts.cause) : undefined;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore https://github.com/tc39/proposal-error-cause\n        super(message, {\n            cause\n        });\n        this.code = code;\n        this.cause = cause;\n        this.name = 'TRPCError';\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n\nfunction invert(obj) {\n    const newObj = Object.create(null);\n    for(const key in obj){\n        const v = obj[key];\n        newObj[v] = key;\n    }\n    return newObj;\n}\n\n// reference: https://www.jsonrpc.org/specification\n/**\n * JSON-RPC 2.0 Error codes\n *\n * `-32000` to `-32099` are reserved for implementation-defined server-errors.\n * For tRPC we're copying the last digits of HTTP 4XX errors.\n */ const TRPC_ERROR_CODES_BY_KEY = {\n    /**\n   * Invalid JSON was received by the server.\n   * An error occurred on the server while parsing the JSON text.\n   */ PARSE_ERROR: -32700,\n    /**\n   * The JSON sent is not a valid Request object.\n   */ BAD_REQUEST: -32600,\n    /**\n   * Internal JSON-RPC error.\n   */ INTERNAL_SERVER_ERROR: -32603,\n    // Implementation specific errors\n    UNAUTHORIZED: -32001,\n    FORBIDDEN: -32003,\n    NOT_FOUND: -32004,\n    METHOD_NOT_SUPPORTED: -32005,\n    TIMEOUT: -32008,\n    CONFLICT: -32009,\n    PRECONDITION_FAILED: -32012,\n    PAYLOAD_TOO_LARGE: -32013,\n    TOO_MANY_REQUESTS: -32029,\n    CLIENT_CLOSED_REQUEST: -32099\n};\ninvert(TRPC_ERROR_CODES_BY_KEY);\n\nconst TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);\nconst JSONRPC2_TO_HTTP_CODE = {\n    PARSE_ERROR: 400,\n    BAD_REQUEST: 400,\n    NOT_FOUND: 404,\n    INTERNAL_SERVER_ERROR: 500,\n    UNAUTHORIZED: 401,\n    FORBIDDEN: 403,\n    TIMEOUT: 408,\n    CONFLICT: 409,\n    CLIENT_CLOSED_REQUEST: 499,\n    PRECONDITION_FAILED: 412,\n    PAYLOAD_TOO_LARGE: 413,\n    METHOD_NOT_SUPPORTED: 405,\n    TOO_MANY_REQUESTS: 429\n};\nfunction getStatusCodeFromKey(code) {\n    return JSONRPC2_TO_HTTP_CODE[code] ?? 500;\n}\nfunction getHTTPStatusCode(json) {\n    const arr = Array.isArray(json) ? json : [\n        json\n    ];\n    const httpStatuses = new Set(arr.map((res)=>{\n        if ('error' in res) {\n            const data = res.error.data;\n            if (typeof data.httpStatus === 'number') {\n                return data.httpStatus;\n            }\n            const code = TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n            return getStatusCodeFromKey(code);\n        }\n        return 200;\n    }));\n    if (httpStatuses.size !== 1) {\n        return 207;\n    }\n    const httpStatus = httpStatuses.values().next().value;\n    return httpStatus;\n}\n/**\n * @internal\n */ function callProcedure(opts) {\n    const { type , path  } = opts;\n    if (!(path in opts.procedures) || !opts.procedures[path]?._def[type]) {\n        throw new TRPCError({\n            code: 'NOT_FOUND',\n            message: `No \"${type}\"-procedure on path \"${path}\"`\n        });\n    }\n    const procedure = opts.procedures[path];\n    return procedure(opts);\n}\n\n/**\n * The default check to see if we're in a server\n */ typeof window === 'undefined' || 'Deno' in window || globalThis.process?.env?.NODE_ENV === 'test' || !!globalThis.process?.env?.JEST_WORKER_ID;\n\nfunction getPath(args) {\n  const p = args.params.trpc;\n  if (typeof p === \"string\") {\n    return p;\n  }\n  if (Array.isArray(p)) {\n    return p.join(\"/\");\n  }\n  return null;\n}\nfunction notFoundError(opts) {\n  const error = opts.router.getErrorShape({\n    error: new TRPCError({\n      message: 'Query \"trpc\" not found - is the file named `[trpc]`.ts or `[...trpc].ts`?',\n      code: \"INTERNAL_SERVER_ERROR\"\n    }),\n    type: \"unknown\",\n    ctx: undefined,\n    path: undefined,\n    input: undefined\n  });\n  const json = {\n    id: -1,\n    error\n  };\n  return new Response(JSON.stringify(json), {\n    status: 500\n  });\n}\n\nfunction transformTRPCResponseItem(router, item) {\n    if ('error' in item) {\n        return {\n            ...item,\n            error: router._def._config.transformer.output.serialize(item.error)\n        };\n    }\n    if ('data' in item.result) {\n        return {\n            ...item,\n            result: {\n                ...item.result,\n                data: router._def._config.transformer.output.serialize(item.result.data)\n            }\n        };\n    }\n    return item;\n}\n/**\n * Takes a unserialized `TRPCResponse` and serializes it with the router's transformers\n **/ function transformTRPCResponse(router, itemOrItems) {\n    return Array.isArray(itemOrItems) ? itemOrItems.map((item)=>transformTRPCResponseItem(router, item)) : transformTRPCResponseItem(router, itemOrItems);\n}\n\nconst HTTP_METHOD_PROCEDURE_TYPE_MAP = {\n    GET: 'query',\n    POST: 'mutation'\n};\nfunction getRawProcedureInputOrThrow(req) {\n    try {\n        if (req.method === 'GET') {\n            if (!req.query.has('input')) {\n                return undefined;\n            }\n            const raw = req.query.get('input');\n            return JSON.parse(raw);\n        }\n        if (typeof req.body === 'string') {\n            // A mutation with no inputs will have req.body === ''\n            return req.body.length === 0 ? undefined : JSON.parse(req.body);\n        }\n        return req.body;\n    } catch (err) {\n        throw new TRPCError({\n            code: 'PARSE_ERROR',\n            cause: getCauseFromUnknown(err)\n        });\n    }\n}\nasync function resolveHTTPResponse(opts) {\n    const { createContext , onError , router , req  } = opts;\n    const batchingEnabled = opts.batching?.enabled ?? true;\n    if (req.method === 'HEAD') {\n        // can be used for lambda warmup\n        return {\n            status: 204\n        };\n    }\n    const type = HTTP_METHOD_PROCEDURE_TYPE_MAP[req.method] ?? 'unknown';\n    let ctx = undefined;\n    let paths = undefined;\n    const isBatchCall = !!req.query.get('batch');\n    function endResponse(untransformedJSON, errors) {\n        let status = getHTTPStatusCode(untransformedJSON);\n        const headers = {\n            'Content-Type': 'application/json'\n        };\n        const meta = opts.responseMeta?.({\n            ctx,\n            paths,\n            type,\n            data: Array.isArray(untransformedJSON) ? untransformedJSON : [\n                untransformedJSON\n            ],\n            errors\n        }) ?? {};\n        for (const [key, value] of Object.entries(meta.headers ?? {})){\n            headers[key] = value;\n        }\n        if (meta.status) {\n            status = meta.status;\n        }\n        const transformedJSON = transformTRPCResponse(router, untransformedJSON);\n        const body = JSON.stringify(transformedJSON);\n        return {\n            body,\n            status,\n            headers\n        };\n    }\n    try {\n        if (opts.error) {\n            throw opts.error;\n        }\n        if (isBatchCall && !batchingEnabled) {\n            throw new Error(`Batching is not enabled on the server`);\n        }\n        /* istanbul ignore if  */ if (type === 'subscription') {\n            throw new TRPCError({\n                message: 'Subscriptions should use wsLink',\n                code: 'METHOD_NOT_SUPPORTED'\n            });\n        }\n        if (type === 'unknown') {\n            throw new TRPCError({\n                message: `Unexpected request method ${req.method}`,\n                code: 'METHOD_NOT_SUPPORTED'\n            });\n        }\n        const rawInput = getRawProcedureInputOrThrow(req);\n        paths = isBatchCall ? opts.path.split(',') : [\n            opts.path\n        ];\n        ctx = await createContext();\n        const deserializeInputValue = (rawValue)=>{\n            return typeof rawValue !== 'undefined' ? router._def._config.transformer.input.deserialize(rawValue) : rawValue;\n        };\n        const getInputs = ()=>{\n            if (!isBatchCall) {\n                return {\n                    0: deserializeInputValue(rawInput)\n                };\n            }\n            /* istanbul ignore if  */ if (rawInput == null || typeof rawInput !== 'object' || Array.isArray(rawInput)) {\n                throw new TRPCError({\n                    code: 'BAD_REQUEST',\n                    message: '\"input\" needs to be an object when doing a batch call'\n                });\n            }\n            const input = {};\n            for(const key in rawInput){\n                const k = key;\n                const rawValue = rawInput[k];\n                const value = deserializeInputValue(rawValue);\n                input[k] = value;\n            }\n            return input;\n        };\n        const inputs = getInputs();\n        const rawResults = await Promise.all(paths.map(async (path, index)=>{\n            const input = inputs[index];\n            try {\n                const output = await callProcedure({\n                    procedures: router._def.procedures,\n                    path,\n                    rawInput: input,\n                    ctx,\n                    type\n                });\n                return {\n                    input,\n                    path,\n                    data: output\n                };\n            } catch (cause) {\n                const error = getTRPCErrorFromUnknown(cause);\n                onError?.({\n                    error,\n                    path,\n                    input,\n                    ctx,\n                    type: type,\n                    req\n                });\n                return {\n                    input,\n                    path,\n                    error\n                };\n            }\n        }));\n        const errors = rawResults.flatMap((obj)=>obj.error ? [\n                obj.error\n            ] : []);\n        const resultEnvelopes = rawResults.map((obj)=>{\n            const { path , input  } = obj;\n            if (obj.error) {\n                return {\n                    error: router.getErrorShape({\n                        error: obj.error,\n                        type,\n                        path,\n                        input,\n                        ctx\n                    })\n                };\n            } else {\n                return {\n                    result: {\n                        data: obj.data\n                    }\n                };\n            }\n        });\n        const result = isBatchCall ? resultEnvelopes : resultEnvelopes[0];\n        return endResponse(result, errors);\n    } catch (cause) {\n        // we get here if\n        // - batching is called when it's not enabled\n        // - `createContext()` throws\n        // - post body is too large\n        // - input deserialization fails\n        const error = getTRPCErrorFromUnknown(cause);\n        onError?.({\n            error,\n            path: undefined,\n            input: undefined,\n            ctx,\n            type: type,\n            req\n        });\n        return endResponse({\n            error: router.getErrorShape({\n                error,\n                type,\n                path: undefined,\n                input: undefined,\n                ctx\n            })\n        }, [\n            error\n        ]);\n    }\n}\n\nfunction createSolidAPIHandler(opts) {\n  return async args => {\n    const path = getPath(args);\n    if (path === null) {\n      return notFoundError(opts);\n    }\n    const res = {\n      headers: {}\n    };\n    const url = new URL(args.request.url);\n    const req = {\n      query: url.searchParams,\n      method: args.request.method,\n      headers: Object.fromEntries(args.request.headers),\n      body: await args.request.text()\n    };\n    const result = await resolveHTTPResponse({\n      router: opts.router,\n      responseMeta: opts.responseMeta,\n      req,\n      path,\n      createContext: async () => await opts.createContext?.({\n        req: args.request,\n        res\n      })\n    });\n    const mRes = new Response(result.body, {\n      status: result.status\n    });\n    for (const [key, value] of Object.entries(result.headers ? {\n      ...res.headers,\n      ...result.headers\n    } : res.headers)) {\n      if (typeof value === \"undefined\") {\n        continue;\n      }\n      if (typeof value === \"string\") {\n        mRes.headers.set(key, value);\n        continue;\n      }\n      for (const v of value) {\n        mRes.headers.append(key, v);\n      }\n    }\n    return mRes;\n  };\n}\n\nexport { createSolidAPIHandler };\n","start":1676889522758,"end":1676889522758,"order":"normal"}]}
